[{"title":"STM32之fromelf的使用","path":"/MCU开发/STM32之fromelf的使用/","content":"一、生成bin文件fromelf --bin -o UWBStation.bin UWBStation/UWBStation.axf 或者 fromelf --bin -o @L.bin #L 二、生成反汇编文件fromelf --text -a -c -o @L.dis #L","tags":["STM32"],"categories":["MCU开发"]},{"title":"ST产品型号解析","path":"/MCU开发/ST产品型号解析/","content":"STM32 STM8 产品型号 STM32MPU产品型号","tags":["STM32"],"categories":["MCU开发"]},{"title":"TCP/IP协议概述","path":"/通讯协议/TCP-IP协议概述/","content":"一、网络分层体系1、OSI参考模型OSI 参考模型（Open Systems Interconnection Reference Model）是由国际标准化组织（ISO）制定的网络通信框架标准，通过定义七层标准化通信体系，为不同厂商设备互联提供统一规范： 目的：解决早期网络设备兼容性问题，实现跨厂商、跨平台的互联互通； 核心思想：分层解耦，每层专注特定功能，下层为上层提供服务； 意义：虽实际网络中TCPIP协议栈更常用，但OSI模型仍是网络协议设计的理论基础和教学工具。 2、TCPIP的分层网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能。TCPIP分层模型是互联网协议套件的基础，它简化了OSI模型，将网络通信过程划分为四个层次。TCPIP模型的主要目的是提供一个实际可行的网络通信架构，它是互联网和许多其他网络的基础。TCP IP，是一组不同层次上的多个协议的组合。 TCP IP通常被认为是一个四层协议系统，如下图所示。 应用层：定义数据格式与交互规则，提供 HTTP、FTP、SMTP、DNS 等协议，通过端口与传输层衔接，实现多应用并发。 传输层：通过端口复用实现端到端通信；TCP 提供可靠连接、重传与拥塞控制，UDP 仅增加端口与可选校验，高效但不可靠。 网络层：以 IP 为核心，负责跨网寻址、路由与转发；配套 ICMP、IGMP、ARP 实现差错报告、组播管理和地址解析，支持分片重组，构建全球统一地址空间。 链路层：处理比特流传输，将报文封装成帧，添加 MAC 地址与 CRC；通过 ARP 解析硬件地址，实现局域网互联，为 TCPIP 提供无差别的帧级传输接口。 OSI七层模型是网络通信的理论标准，TCPIP四层则是实际应用的简化版本，通过分层协作实现了高效的数据传输。 OSI分层 TCPIP四层 典型协议单元 功能简述 应用层 应用层 HTTP, FTP, SMTP, DNS 用户业务数据格式与交互规则 表示层 应用层 SSLTLS, JPEG, ASCII 数据加密、压缩、格式转换 会话层 应用层 RPC, NetBIOS 会话建立、维持、终止 传输层 传输层 TCP, UDP 端到端可靠不可靠传输、端口复用 网络层 网络层 IP, ICMP, IGMP, ARP 跨网寻址、路由、分片、差错报告 数据链路层 链路层 Ethernet, PPP, ARP 帧封装、MAC 寻址、差错检测 物理层 链路层 比特流, RJ-45, 光纤 电气光学信号、比特传输 二、数据的封装和分用当应用程序用 TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程叫做数据的封装。当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作数据的分用。过程如下所示。 三、以太网帧数据的传输在讲述网络传输之前，了解以下网络中的名词是十分重要的。 名称 所在层级 作用域 核心职能 IP 地址 网络层 (L3) 全网逻辑 跨网络标识主机，决定“去哪”；与掩码配合判断本地远程 MAC 地址 链路层 (L2) 本地物理段 固化标识网卡，同网段内“交给谁” 子网掩码 网络层 (L3) 主机本地 划分 IP 中的网络位与主机位，决定“是否同一网段” 网关 (默认路由) 网络层 (L3) 跨网段 提供下一跳 IP，把远程流量送出本段 交换机 链路层 (L2) 单广播域 自学习 MAC 地址，按表二层转发帧，隔离冲突域 路由器 网络层 (L3) 多广播域 查 IP 路由表，跨网转发包，隔离广播，实现网际互联 CAM表 链路层 (L2) 交换机内部 MAC-端口映射表，用于快速硬件查表，决定帧从哪个端口发出 路由表 网络层 (L3) 路由器内部 目的网络-下一跳-出接口映射，指导 IP 报文跨网转发 1、局域网间通讯 如（图）网络传输所示，若电脑A与电脑B通讯，数据传输步骤如下所示： 电脑A用子网掩码判断目标IP与自身同网段 → 走局域网直接交付。 电脑A查本地ARP缓存： 命中 → 直接得到电脑B的MAC； 未命中 → A发ARP请求（广播），B单播回应MAC，A缓存并填充帧头。 电脑A构造以太网帧：目的MACB，源MACA，类型0x0800，载荷为IP报文。 帧进入交换机A： 交换机A学习源MAC，更新CAM表； 查目的MAC，若表项存在则单播转发到对应端口；若无表项则泛洪到同一VLAN内所有端口（除源端口）。 电脑B收到帧，FCS校验正确后解封→交IP层→确认目的IP为本机，完成通信。 2、跨网络通讯如（图）网络传输所示，若电脑A与电脑E通讯，数据传输步骤如下所示： 电脑A用子网掩码判断目标IP与自身不同网段 → 需走默认网关。 电脑A查本地ARP缓存： 命中 → 直接得到网关MAC； 未命中 → A发ARP请求（广播），网关单播回应MAC，A缓存并填充帧头。 电脑A构造以太网帧：目的MAC网关，源MACA，类型0x0800，载荷为IP报文（目的IPE）。 帧进入交换机A： 学习源MAC，更新CAM表； 查目的MAC命中网关端口，单播转发给路由器A。 路由器A收帧→解封至IP层→查路由表得下一跳（路由器B接口）→减TTL→重新封装新帧： 目的MAC路由器B接口MAC，源MAC本出接口MAC。 帧经交换机B（若存在）→送达路由器B。 路由器B解封→查路由表得目的网络直连本地接口→查ARP缓存： 命中 → 直接得到电脑E的MAC； 未命中 → B发ARP请求（广播），E单播回应MAC，B缓存并填充帧头。 路由器B构造末帧：目的MACE，源MAC本接口MAC，类型0x0800，发往交换机C。 交换机C学习源MAC，查目的MAC命中E端口，单播转发。 电脑E收到帧，FCS校验正确后解封→交IP层→确认目的IP为本机，完成跨网络通信。","tags":["TCP/IP"],"categories":["通讯协议"]},{"title":"RT-Thread之邮箱使用示例","path":"/RTOS/RT-Thread之邮箱使用示例/","content":"邮箱（Mailbox）是RT-Thread中高效的线程间通信机制，其核心特点是： 传输固定尺寸数据：每条消息为4字节（32位系统），可传递整型或指针 轻量级通信：比消息队列更节省内存，适用于小数据量场景 优先级传递：支持紧急消息优先处理 典型应用场景： 在硬件中断服务中，通过rt_mb_send快速传递传感器状态字，消费线程解析后触发相应动作，避免中断长时间占用CPU资源。 一、邮箱API函数1、邮箱的创建 动态创建邮箱（推荐灵活场景） rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag) 静态创建邮箱 rt_err_t rt_mb_init(rt_mailbox_t mb, const char *name, void *msgpool, rt_size_t size, rt_uint8_t flag) 2、邮箱的发送线程或者中断服务程序都可以通过往邮箱里写入邮件。发送的邮件，可以是32位的任意格式数据，可以是一个整型值或者一个指向某块内存的指针 直接发送邮件：只有在邮箱有可用的空闲空间时，才能成功发送消息，否则返回错误。 rt_err_t rt_mb_send(rt_mailbox_t mb, rt_ubase_t value) 等待发送邮件：如果邮箱没有可用的空闲空间，会根据timeout参数等待，超时后才返回错误。 rt_err_t rt_mb_send_wait(rt_mailbox_t mb, rt_ubase_t value, rt_int32_t timeout) 紧急发送邮件：只有在邮箱有可用的空闲空间，它才会把邮件插在邮件队首，以便这个邮件能被第1时间读取。 rt_err_t rt_mb_urgent(rt_mailbox_t mb, rt_ubase_t value) 3、消息的接收当邮箱有邮件时，使用收邮件函数，可以从邮箱接收邮件。如果没有邮件，根据指定的timeout参数等待，直到超时结束。 rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_ubase_t *value, rt_int32_t timeout) 4、邮箱的脱离删除删除或者脱离邮箱时，如果有线程在等待该邮箱，则内核先唤醒这些线程（线程返回值是RT_ERROR），然后再释放邮箱使用的内存，最后删除邮箱对象。 删除使用 rt_mb_create()创建的队列 rt_err_t rt_mb_delete(rt_mailbox_t mb) 脱离使用 rt_mb_init()初始化的队列 rt_err_t rt_mb_detach(rt_mailbox_t mb) 二、创建邮箱示例1、创建邮箱struct rt_mailbox mb_static;\t/* 邮箱句柄 */uint8_t msgpool[48];\t/* 邮箱静态内存池 *//* 静态创建一个邮箱 */rt_mb_init( mb_static, /* 邮箱对象的句柄 */ mb_static_test, /* 邮箱对象名称 */ msgpool, /* 内存池指向 */ sizeof(msgpool) / 4, /* 邮箱中能容纳的邮件数量,每封邮件占四字节 */ RT_IPC_FLAG_FIFO /* 如果有多个线程等待，按照先来先得到的方法分配 */);rt_mailbox_t mb_dynamic; /* 邮箱句柄指针 *//* 动态创建一个邮箱 */mb_dynamic = rt_mb_create( mb_dynamic_test, /* 邮箱对象名称 */ 12, /* 邮箱中能容纳的邮件数量,每封邮件占四字节 */ RT_IPC_FLAG_FIFO /* 如果有多个线程等待，按照先来先得到的方法分配 */); 2、接收与发送消息#include thread_task.h#include main.h#include stdio.h #include rtthread.h#include rthw.h/******************************************** 线程 1 ******************************************************/#define THREAD_1_PRIORITY 4 /* 进程优先级 */#define THREAD_1_STACK_SIZE 512 /* 进程栈空间大小 */#define THREAD_1_TIMESLICE 10 /* 进程执行时间片个数 */static struct rt_thread *thread_1_handle; /* 进程句柄 *//******************************************** 线程 2 ******************************************************/#define THREAD_2_PRIORITY 5 /* 进程优先级 */#define THREAD_2_STACK_SIZE 512 /* 进程栈空间大小 */#define THREAD_2_TIMESLICE 10 /* 进程执行时间片个数 */static struct rt_thread *thread_2_handle; /* 进程句柄 */rt_mailbox_t mb_dynamic; /* 邮箱句柄指针 *//** * @brief 线程1入口函数 * @param 无 * @retval 无 */void thread_1_entry(void* param) uint32_t value = 0; while(1) rt_thread_delay(4000); /* 精准延时4000时间片 */ rt_mb_recv(mb_dynamic, value, 0xffffffff); HAL_GPIO_TogglePin(GPIOC, LED1_Pin); /** * @brief 线程2入口函数 * @param 无 * @retval 无 */void thread_2_entry(void* param) while(1) rt_mb_send_wait(mb_dynamic, (uint32_t)0x01, 0xffffffff); HAL_GPIO_TogglePin(GPIOC, LED2_Pin); rt_thread_delay(200); /** * @brief 动态创建线程任务并启动 * @param 无 * @retval 无 */void ThreadStart(void) rt_base_t level = rt_hw_interrupt_disable(); /* 动态创建线程 */ thread_1_handle = rt_thread_create( thread_1, /* 线程句柄名称*/ thread_1_entry, /* 函数入口 */ RT_NULL, /* 入口函数参数 */ THREAD_1_STACK_SIZE,\t/* 线程栈大小 */ THREAD_1_PRIORITY, /* 线程优先级 */ THREAD_1_TIMESLICE /* 线程时间片大小 */ ); rt_thread_startup(thread_1_handle); /* 启动线程 */ thread_2_handle = rt_thread_create( thread_2, /* 线程句柄名称*/ thread_2_entry, /* 函数入口 */ RT_NULL, /* 入口函数参数 */ THREAD_2_STACK_SIZE,\t/* 线程栈大小 */ THREAD_2_PRIORITY, /* 线程优先级 */ THREAD_2_TIMESLICE /* 线程时间片大小 */ ); rt_thread_startup(thread_2_handle); /* 启动线程 */ /* 动态创建邮箱 */ mb_dynamic = rt_mb_create( mb_dynamic_test, 12, RT_IPC_FLAG_FIFO ); rt_hw_interrupt_enable(level); 执行流程如下： （1）初始阶段 线程1立即阻塞等待消息（邮箱空） 线程2开始高频发送（每200 ticks发送1次） （2）邮箱填满阶段 线程2发送12条消息后邮箱满 → rt_mb_send_wait()开始阻塞 系统进入双阻塞状态（线程1和2均挂起） （3）恢复同步阶段 线程1的rt_thread_delay(4000)到期后： 消费1条消息 → 释放1个邮箱槽位 唤醒线程2继续发送 稳定状态：每4000 ticks消费1条，线程2每200 ticks补充1条","tags":["RT-Thread"],"categories":["RTOS"]},{"title":"RT-Thread之消息队列使用示例","path":"/RTOS/RT-Thread之消息队列使用示例/","content":"消息队列（Message Queue）是一种异步通信机制，其核心功能是： 解耦生产者和消费者：发送方和接收方无需同时在线 缓冲与流量整形：应对瞬时流量过载 优先级处理：支持紧急消息插队 典型案例： 在RT-Thread中，中断服务程序（ISR）通过rt_mq_send非阻塞发送传感器数据，消费者线程按需从队列读取数据，避免ISR因等待导致实时性下降。 一、消息队列API函数1、消息队列的创建 动态创建消息队列 rt_mq_t rt_mq_create(const char *name, rt_size_t msg_size, rt_size_t max_msgs, rt_uint8_t flag) 静态创建消息队列 rt_err_t rt_mq_init(rt_mq_t mq, const char *name, void *msgpool, rt_size_t msg_size, rt_size_t pool_size, rt_uint8_t flag) 2、消息的发送发送消息时，从空闲消息链表取一个空闲消息块，把消息复制到该消息块，然后把消息块挂到消息队列尾部。消息的发送有以下三种： 直接发送消息 队列中有空闲消息块时，才能成功发送消息，否则返回错误。 rt_err_t rt_mq_send(rt_mq_t mq, const void *buffer, rt_size_t size) 等待发送消息 如果队列中没有可用的空闲消息块，会根据timeout参数等待，超时后才返回错误。 rt_err_t rt_mq_send_wait(rt_mq_t mq, const void *buffer, rt_size_t size, rt_int32_t timeout) 紧急发送消息 它会把消息块放在消息队列的头部，以便这个消息能被第1时间读取。 rt_err_t rt_mq_urgent(rt_mq_t mq, const void *buffer, rt_size_t size) 3、消息的接收当队列有消息时，使用收消息函数，可以从队列接收消息；如果没有消息，根据指定的 timeout 参数等待，直到超时结束。 rt_err_t rt_mq_recv(rt_mq_t mq, void *buffer, rt_size_t size, rt_int32_t timeout) 4、消息队列的脱离删除 删除使用 rt_mq_create()创建的队列 rt_err_t rt_mq_delete(rt_mq_t mq) 脱离使用 rt_mq_init()初始化的队列 rt_err_t rt_mq_detach(rt_mq_t mq) 二、创建消息队列示例1、创建消息队列/* 使用静态创建（确定内存占用）\t*/struct rt_messagequeue mq_static;uint8_t msgpool[96]; /* 消息数量计算：96/(RT_ALIGN(2,4)+4)=12条消息 */rt_mq_init( mq_static, /* 消息队列对象的句柄 */ smq, /* 消息队列的名字 */ msgpool, /* 内存池指向的地址 */ 2, /* 每一个消息占2字节 */ 96, /* 内存池的大小 */ RT_IPC_FLAG_FIFO); /* 选择线程唤醒的顺序方式 *//* 使用动态创建（灵活调整） */rt_mq_t mq_dynamic = rt_mq_create( dmq, /* 消息队列名称 */ 2, /* 每一个消息大小 */ 12, /* 消息数量 */ RT_IPC_FLAG_FIFO); /* 选择线程唤醒的顺序方式 */ 2、完整示例#include thread_task.h#include main.h#include stdio.h #include rtthread.h#include rthw.h/******************************************** 线程 1 ******************************************************/#define THREAD_1_PRIORITY 4 /* 进程优先级 */#define THREAD_1_STACK_SIZE 512 /* 进程栈空间大小 */#define THREAD_1_TIMESLICE 10 /* 进程执行时间片个数 */static struct rt_thread *thread_1_handle; /* 进程句柄 *//******************************************** 线程 2 ******************************************************/#define THREAD_2_PRIORITY 5 /* 进程优先级 */#define THREAD_2_STACK_SIZE 512 /* 进程栈空间大小 */#define THREAD_2_TIMESLICE 10 /* 进程执行时间片个数 */static struct rt_thread *thread_2_handle; /* 进程句柄 *//* 消息队列 */rt_mq_t mq_test;/** * @brief 线程1入口函数 * @param 无 * @retval 无 */void thread_1_entry(void* param) uint8_t buffer[2]; while(1) rt_mq_recv(mq_test, buffer, 2, 0xffffffff); HAL_GPIO_TogglePin(GPIOC, LED1_Pin); rt_thread_delay(4000); /* 精准延时1000时间片 */ /** * @brief 线程2入口函数 * @param 无 * @retval 无 */void thread_2_entry(void* param) uint8_t text[2] = 0,1; while(1) text[0] ++; rt_mq_send_wait(mq_test, text, 2, 0xffff); HAL_GPIO_TogglePin(GPIOC, LED2_Pin); rt_thread_delay(200); /** * @brief 动态创建线程任务并启动 * @param 无 * @retval 无 */void ThreadStart(void) rt_base_t level = rt_hw_interrupt_disable(); /* 动态创建线程 */ thread_1_handle = rt_thread_create( thread_1, /* 线程句柄名称*/ thread_1_entry, /* 函数入口 */ RT_NULL, /* 入口函数参数 */ THREAD_1_STACK_SIZE,\t/* 线程栈大小 */ THREAD_1_PRIORITY, /* 线程优先级 */ THREAD_1_TIMESLICE /* 线程时间片大小 */ ); rt_thread_startup(thread_1_handle); /* 启动线程 */ thread_2_handle = rt_thread_create( thread_2, /* 线程句柄名称*/ thread_2_entry, /* 函数入口 */ RT_NULL, /* 入口函数参数 */ THREAD_2_STACK_SIZE,\t/* 线程栈大小 */ THREAD_2_PRIORITY, /* 线程优先级 */ THREAD_2_TIMESLICE /* 线程时间片大小 */ ); rt_thread_startup(thread_2_handle); /* 启动线程 */\t/* 动态创建一个消息队列 */ mq_test = rt_mq_create( mq_test, /* 消息队列名称 */ 2, /* 消息大小 */ 12, /* 消息数量 */ RT_IPC_FLAG_FIFO /* 选择线程唤醒的顺序方式 */ ); rt_hw_interrupt_enable(level); 执行流程如下: 初始阶段 线程1立即阻塞等待消息（队列空） 线程2开始高频发送（每200 ticks发送1次） 队列填满阶段 线程2发送12条消息后队列满 → rt_mq_send_wait()开始阻塞 系统进入双阻塞状态（线程1和2均挂起） 恢复同步阶段 线程1的rt_thread_delay(4000)到期后： 消费1条消息 → 释放1个队列空间 唤醒线程2继续发送 稳定状态：每4000 ticks消费1条，线程2每200 ticks补充1条","tags":["RT-Thread"],"categories":["RTOS"]},{"title":"RT-Thread之四种延时函数","path":"/RTOS/RT-Thread之四种延时函数/","content":"在RT-Thread实时操作系统中，延时函数是实现任务调度的关键工具。它们允许任务在指定的时间间隔内挂起，释放CPU资源供其他任务运行，从而提高系统响应性和资源利用率。RT-Thread提供了四种主要的延时函数： 绝对延时（精准延时） rt_err_t rt_thread_delay_until(rt_tick_t *tick, rt_tick_t inc_tick) 相对延时（基于当前时间） rt_err_t rt_thread_delay(rt_tick_t tick) 毫秒级延时 rt_err_t rt_thread_mdelay(rt_int32_t ms) 微秒级硬件延时（可基于基于DWT或定时器） RT_WEAK void rt_hw_us_delay(rt_uint32_t us) 注意：前三个函数受系统tick影响，tick （1 RT_TICK_PER_SECOND）秒，其中RT_TICK_PER_SECOND默认为1000，即默认tick 1ms。 一、rt_thread_delay_until()函数此函数提供一个固定周期的精准延时，其特点是基于预计算的绝对时间，而不是从调用时刻开始计时。这意味着它可以避免累积误差，适用于需要严格定时周期性任务的场景（如PID控制、ADC采样等）。 注意：在对时域算法离散化时，dt步长尤为重要，它关乎系统的稳定和精度！ /** * @brief 线程2入口函数 * @param 无 * @retval 无 */void thread_2_entry(void* param) while(1) rt_tick_t now_tick = rt_tick_get(); /* 获取当前时间,从此刻记时 */ sys_conrtol(); /* 再延时（ticks） = 1000 - sys_conrtol()执行时间 */ /* 保证sys_conrtol()执行周期为严格的1000个ticks */ rt_thread_delay_until(now_tick, 1000); 关键点： 必须用 last_tick（指针）传输上次延时结束时的时间，以实现精准循环。 适用于需要严格时间间隔的任务，如PWM控制、传感器采样等。 长时间运行也不会出现累积误差。 二、rt_thread_delay()函数该函数实现相对延时，即从当前时刻开始挂起线程 delay 个系统时钟节拍（tick）。它的特点是计算简单，但如果在任务中有其他耗时操作，可能导致周期不稳定。 /** * @brief 线程2入口函数 * @param 无 * @retval 无 */void thread_2_entry(void* param) while(1) sys_conrtol(); /* 再延时时间（ticks） = 1000 */ /* sys_conrtol()函数执行时间不确定，实际执行周期 1000 ticks*/ rt_thread_delay(1000); 关键点： 适用于不要求严格周期的任务，如后台日志打印、网络轮询。 如果任务本身的执行时间较长，会导致总周期不再是准确的 delay。 RT-Thread的系统tick通常为1ms（默认配置），delay=1000 表示1000ms（1秒）。 用户可通过修改RT_TICK_PER_SECOND调整tick分辨率，但需权衡系统性能。 三、rt_thread_mdelay()函数由于 rt_thread_delay() 的延时单位是系统tick（默认1ms），而 rt_thread_mdelay() 直接指定毫秒（ms）单位，更方便开发者进行计算。 /** * @brief 线程2入口函数 * @param 无 * @retval 无 */void thread_2_entry(void* param) while(1) sys_conrtol(); /* 再延时时间（ticks） = 1000 */ /* sys_conrtol()函数执行时间不确定，实际执行周期 1000 ms*/ rt_thread_mdelay(1000); 关键点： 本质上仍然是 基于 rt_thread_delay 的封装，适用于需要直接使用毫秒单位的情况。 常用于设备轮询、IO等待等场景。 延时精度受限于tick分辨率。 四、rt_hw_us_delay()函数这是基于CPU空循环实现的硬件级延时，精度远高于 rt_thread_delay 或 rt_thread_mdelay，适用于短时间、高精度的任务（如SPII2C通信时序控制）。 注意： 不会触发线程调度，适用于短延时，长时间延时应优先使用调度函数 依赖于CPU频率，部分STM32MCU可能需要调整delay_us的计算方式。 部分芯片不支持需自己实现。 ...... /* 拉低CS片选信号 */rt_pin_write(SPI_CS_PIN, PIN_LOW);/* 10us延时（确保SPI设备就绪） */rt_hw_us_delay(10);/* SPI数据传输 */rt_spi_send(spi_dev, data, 1);/* 拉高CS */rt_pin_write(SPI_CS_PIN, PIN_HIGH);...... 关键点： 适用于硬件驱动开发（如GPIO、SPI、I2C）。 慎用在主线程，否则会阻塞其他任务运行 RT-Thread提供了四种不同的延时方式，适用于不同精度的任务调度需求。合理选择延时函数可以提高系统的实时性和稳定性。 欢迎关注本人微信公众号：","tags":["RT-Thread"],"categories":["RTOS"]},{"title":"PM004MNIA驱动","path":"/驱动/PM004MNIA驱动/","content":"概述STT-MRAM PM004MNIA 是一种具有 随机存取（Random Access） 特性的非易失性存储器，无需擦除操作，可进行 任意地址的读写操作。它的核心基于 自旋转移扭矩（Spin Transfer Torque, STT） 技术，通过控制电流方向来改变磁性存储单元的状态，从而实现数据的存储与读取。支持写无延迟（Write No Delay） 的特性，显著提高了存储效率。 广泛应用于需要 高速读写、低功耗和长期数据保存 的场景，例如 IoT 设备、工业控制模块、可穿戴设备、传感器系统 等。 特性 描述 存储容量 4Mbit 存储技术 自旋转移扭矩磁随机存取存储器（STT-MRAM） 随机存取能力 支持任意地址的读写操作，无需擦除，写入延迟低 接口支持 SPI 和 QPI（四线并行） 最大 SPI 频率 50MHz 低功耗 Sleep 模式下仅需 2μA 数据保留时间 可达 20 年（在 85°C 环境下） 写入耐久性 支持高达 10⁸ 次 PE 周期 写保护功能 支持配置写保护区域，确保数据安全 附录-使用STM32H750驱动程序1、外设初始化文件 quadspi.c文件 #include quadspi.hQSPI_HandleTypeDef hqspi;/** * @brief quad spi 外设初始化函数 * @param 无 * @retval 无 */ void QUADSPI_Init(void)\thqspi.Instance = QUADSPI;\thqspi.Init.ClockPrescaler = 5; /* QSPI时钟预分频器（决定实际通信时钟频率） */\thqspi.Init.FifoThreshold = 32; /* FIFO阈值（单位：字节），当FIFO中的数据量达到该值时触发中断/DMA请求 */\t/* 采样移位模式： * HALFCYCLE：在时钟半周期时采样（提高时序余量） * NONE：不在半周期采样 */\thqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE;\thqspi.Init.FlashSize = 23 - 1; /* FLASH内存大小 = 2 ^ (FlashSize + 1) */ /* 片选高电平时间： * 表示两次传输之间CS保持高电平的最小时钟周期数 */\thqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE; /* 时钟模式： * MODE_0：CLK空闲低电平，第1边沿（上升沿）采样 * MODE_3：CLK空闲高电平，第2边沿（下降沿）采样 * 需与Flash芯片规格书一致 */\thqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;\t/* Flash芯片选择： * ID_1：使用Bank1（对应BK1_IOx引脚） * ID_2：使用Bank2（仅双Flash模式） */\thqspi.Init.FlashID = QSPI_FLASH_ID_1;\t/* 双Flash模式： * DISABLE：单Flash模式 * ENABLE：并联两个Flash（地址空间翻倍） */\thqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;\tif (HAL_QSPI_Init(hqspi) != HAL_OK) Error_Handler();\t/** * @brief quad spi 外设初始化回调函数 * @param qspiHandle：QSPI句柄 * @retval 无 */ void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)\tGPIO_InitTypeDef GPIO_InitStruct = 0;\tRCC_PeriphCLKInitTypeDef PeriphClkInitStruct = 0;\tif(qspiHandle-Instance==QUADSPI) /** Initializes the peripherals clock */ PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_QSPI; PeriphClkInitStruct.QspiClockSelection = RCC_QSPICLKSOURCE_D1HCLK; if (HAL_RCCEx_PeriphCLKConfig(PeriphClkInitStruct) != HAL_OK) Error_Handler(); /* QUADSPI clock enable */ __HAL_RCC_QSPI_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); __HAL_RCC_GPIOF_CLK_ENABLE(); /**QUADSPI GPIO Configuration PB6 ------ QUADSPI_BK1_NCS PF6 ------ QUADSPI_BK1_IO3 PF7 ------ QUADSPI_BK1_IO2 PF8 ------ QUADSPI_BK1_IO0 PF10 ------ QUADSPI_CLK PF9 ------ QUADSPI_BK1_IO1 */ GPIO_InitStruct.Pin = GPIO_PIN_6; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI; HAL_GPIO_Init(GPIOB, GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI; HAL_GPIO_Init(GPIOF, GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI; HAL_GPIO_Init(GPIOF, GPIO_InitStruct);\t/** * @brief quad spi 外设重初始化回调函数 * @param qspiHandle：QSPI句柄 * @retval 无 */ void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef* qspiHandle)\tif(qspiHandle-Instance==QUADSPI) /* Peripheral clock disable */ __HAL_RCC_QSPI_CLK_DISABLE(); /**QUADSPI GPIO Configuration PB6 ------ QUADSPI_BK1_NCS PF6 ------ QUADSPI_BK1_IO3 PF7 ------ QUADSPI_BK1_IO2 PF8 ------ QUADSPI_BK1_IO0 PF10 ------ QUADSPI_CLK PF9 ------ QUADSPI_BK1_IO1 */ HAL_GPIO_DeInit(GPIOB, GPIO_PIN_6); HAL_GPIO_DeInit(GPIOF, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_10 |GPIO_PIN_9); quadspi.h文件 #ifndef __QUADSPI_H__#define __QUADSPI_H__#ifdef __cplusplusextern C #endif#include main.h#include string.hextern QSPI_HandleTypeDef hqspi;void QUADSPI_Init(void);#ifdef __cplusplus#endif#endif /* __QUADSPI_H__ */ 2、驱动文件 bsp_pm004mniatr.c文件 #include bsp_pm004mniatr.h#include quadspi.h/** * @brief 读NOR Flash的状态寄存器 * @param addr: 状态寄存器地址(寄存器1、2、3 对应地址为 0x00、0x01、0x02) * @retval 状态寄存器的值 */uint8_t pm004mniatr_read_sr(uint8_t addr) uint8_t byte; QSPI_CommandTypeDef qspi_command_struct = 0; qspi_command_struct.InstructionMode = QSPI_INSTRUCTION_1_LINE; qspi_command_struct.Instruction = PM004MNIATR_COMMAND_READ_MODE_REGISTER; qspi_command_struct.AddressMode = QSPI_ADDRESS_1_LINE;\tqspi_command_struct.AddressSize = QSPI_ADDRESS_24_BITS;\tqspi_command_struct.Address = addr; qspi_command_struct.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE; qspi_command_struct.DummyCycles = 2; qspi_command_struct.DataMode = QSPI_DATA_1_LINE; qspi_command_struct.NbData = 1; qspi_command_struct.DdrMode = QSPI_DDR_MODE_DISABLE; qspi_command_struct.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY; qspi_command_struct.SIOOMode = QSPI_SIOO_INST_EVERY_CMD; HAL_QSPI_Command(hqspi, qspi_command_struct, HAL_QSPI_TIMEOUT_DEFAULT_VALUE); HAL_QSPI_Receive(hqspi, byte, HAL_QSPI_TIMEOUT_DEFAULT_VALUE); return byte;/** * @brief 写NOR Flash的状态寄存器 * @param addr: 状态寄存器地址(寄存器1、2、3 对应地址为 0x00、0x01、0x02) * @param byte：寄存器写入值 * @retval 无 */void pm004mniatr_write_sr(uint8_t addr, uint8_t byte) QSPI_CommandTypeDef qspi_command_struct = 0; qspi_command_struct.InstructionMode = QSPI_INSTRUCTION_1_LINE; qspi_command_struct.Instruction = PM004MNIATR_COMMAND_WRITE_MODE_REGISTER; qspi_command_struct.AddressMode = QSPI_ADDRESS_1_LINE;\tqspi_command_struct.AddressSize = QSPI_ADDRESS_24_BITS;\tqspi_command_struct.Address = addr; qspi_command_struct.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE; qspi_command_struct.DummyCycles = 0; qspi_command_struct.DataMode = QSPI_DATA_1_LINE; qspi_command_struct.NbData = 1; qspi_command_struct.DdrMode = QSPI_DDR_MODE_DISABLE; qspi_command_struct.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY; qspi_command_struct.SIOOMode = QSPI_SIOO_INST_EVERY_CMD; HAL_QSPI_Command(hqspi, qspi_command_struct, HAL_QSPI_TIMEOUT_DEFAULT_VALUE); HAL_QSPI_Transmit(hqspi, byte, HAL_QSPI_TIMEOUT_DEFAULT_VALUE);/** * @brief 发送快速指令 * @param 无 * @retval 无 */void pm004mniatr_send_command(uint8_t command)\tQSPI_CommandTypeDef qspi_command_struct = 0; qspi_command_struct.InstructionMode = QSPI_INSTRUCTION_1_LINE; /* 设置指令模式：使用1线传输模式 */\tqspi_command_struct.Instruction = command; /* 设置指令代码 */\tqspi_command_struct.AddressMode = QSPI_ADDRESS_NONE; /* 地址模式：不使用地址 */\tqspi_command_struct.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE; /* 备用字节模式：不使用 */\tqspi_command_struct.DummyCycles = 0; /* 空周期数：0 */ qspi_command_struct.DataMode = QSPI_DATA_NONE; /* 数据模式：不使用数据传输 */ qspi_command_struct.DdrMode = QSPI_DDR_MODE_DISABLE; /* DDR模式：禁用双倍数据率模式 */\tqspi_command_struct.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY; /* DDR半周期保持：使用模拟延迟 */\tqspi_command_struct.SIOOMode = QSPI_SIOO_INST_EVERY_CMD; /* SIOO模式：每次发送指令 */ HAL_QSPI_Command(hqspi, qspi_command_struct, HAL_QSPI_TIMEOUT_DEFAULT_VALUE);/** * @brief 启用quad spi 操作模式 * @param 无 * @retval 无 */static inline void pm004mniatr_qspi_mode_enable(void) pm004mniatr_send_command(PM004MNIATR_COMMAND_ENTER_QSPI);/** * @brief 退出quad spi 操作模式 * @param 无 * @retval 无 */void inline pm004mniatr_qspi_mode_disable(void) pm004mniatr_send_command(PM004MNIATR_COMMAND_EXIT_QSPI);/** * @brief 写使能NOR Flash * @param 无 * @retval 无 */static inline void pm004mniatr_write_enable(void) pm004mniatr_send_command(PM004MNIATR_COMMAND_WRITE_ENABLE);/** * @brief 进入睡眠模式 * @param 无 * @retval 无 */static inline void pm004mniatr_sleep(void) pm004mniatr_send_command(PM004MNIATR_COMMAND_ENTRY_SLEEP);/** * @brief 唤醒PM004MNIA * @param 无 * @retval 无 */static inline void pm004mniatr_wake_up(void) pm004mniatr_send_command(PM004MNIATR_COMMAND_EXIT_SLEEP);/** * @brief 复位PM004MNIA * @param 无 * @retval 无 */static inline void pm004mniatr_reset(void) pm004mniatr_send_command(PM004MNIATR_COMMAND_RESE_ENABLE); pm004mniatr_send_command(PM004MNIATR_COMMAND_RESET);/** * @brief 初始化 PM004MNIA * @param 无 * @retval 无 */void pm004mniatr_init(void)\t/* 初始化quad spi外设 */ QUADSPI_Init(); /* ------------------安全启动 --------------------*/ delay_ms(20); /* 复位PM004MNIA */ pm004mniatr_reset(); delay_ms(10); /* 进入睡眠状态 */ pm004mniatr_sleep(); delay_ms(10); /* 唤醒 */ pm004mniatr_wake_up(); delay_ms(10); /* ----------------安全启动 END -----------------*/ /* 启动写使能 */\tpm004mniatr_write_enable();\t/* 进入qspi操作模式 */\tpm004mniatr_qspi_mode_enable();/** * @brief 读PM004MNIA芯片ID * @param 无 * @retval PM004MNIA芯片ID */uint16_t pm004mniatr_read_id(void) uint8_t id[16]; QSPI_CommandTypeDef qspi_command_struct = 0; qspi_command_struct.InstructionMode = QSPI_INSTRUCTION_1_LINE; /* 1线指令模式 */ qspi_command_struct.Instruction = PM004MNIATR_COMMAND_READ_ID; /* 读取指令 */ qspi_command_struct.AddressMode = QSPI_ADDRESS_1_LINE; /* 无地址模式 */ qspi_command_struct.AddressSize = QSPI_ADDRESS_24_BITS; /* 24位地址 */ qspi_command_struct.Address = 0x000000; /* 地址 */ qspi_command_struct.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE; /* 无交替字节 */ qspi_command_struct.DummyCycles = 0; /* 空白周期个数 */ qspi_command_struct.DataMode = QSPI_DATA_1_LINE; /* 1线数据模式 */ qspi_command_struct.NbData = 2; qspi_command_struct.DdrMode = QSPI_DDR_MODE_DISABLE; qspi_command_struct.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY; qspi_command_struct.SIOOMode = QSPI_SIOO_INST_EVERY_CMD; HAL_QSPI_Command(hqspi, qspi_command_struct, HAL_QSPI_TIMEOUT_DEFAULT_VALUE); HAL_QSPI_Receive(hqspi, id, HAL_QSPI_TIMEOUT_DEFAULT_VALUE); return (((uint16_t)id[0] 8) | id[1]);/** * @brief 从PM004MNIA指定地址开始读取指定长度的数据 * @param pbuf : 读取到数据保存的地址 * @param addr : 指定开始读取的地址 * @param datalen: 指定读取数据的字节数 * @retval 无 */void pm004mniatr_read_data(uint32_t addr, uint8_t *pbuf, uint16_t datalen) QSPI_CommandTypeDef qspi_command_struct = 0; qspi_command_struct.InstructionMode = QSPI_INSTRUCTION_4_LINES; qspi_command_struct.Instruction = PM004MNIATR_COMMAND_READ_DATA; qspi_command_struct.AddressMode = QSPI_ADDRESS_4_LINES; qspi_command_struct.AddressSize = QSPI_ADDRESS_24_BITS; qspi_command_struct.Address = addr; qspi_command_struct.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE; qspi_command_struct.DummyCycles = 12; qspi_command_struct.DataMode = QSPI_DATA_4_LINES; qspi_command_struct.NbData = datalen; qspi_command_struct.DdrMode = QSPI_DDR_MODE_DISABLE; qspi_command_struct.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY; qspi_command_struct.SIOOMode = QSPI_SIOO_INST_EVERY_CMD; HAL_QSPI_Command(hqspi, qspi_command_struct, HAL_QSPI_TIMEOUT_DEFAULT_VALUE); HAL_QSPI_Receive(hqspi, pbuf, HAL_QSPI_TIMEOUT_DEFAULT_VALUE);/** * @brief PM004MNIA指定地址写入指定长度的数据 * @note 写入数据的长度不能超过指定地址所在页的剩余字节数 * @param addr : 指定开始写入数据的地址 * @param pbuf : 写入数据指针 * @param datalen: 指定写入数据的字节数 * @retval 无 */void pm004mniatr_write_data(uint32_t addr, uint8_t *pbuf, uint16_t datalen) QSPI_CommandTypeDef qspi_command_struct = 0; qspi_command_struct.InstructionMode = QSPI_INSTRUCTION_4_LINES; qspi_command_struct.Instruction = PM004MNIATR_COMMAND_WRITE_DATA; qspi_command_struct.AddressMode = QSPI_ADDRESS_4_LINES; qspi_command_struct.AddressSize = QSPI_ADDRESS_24_BITS; qspi_command_struct.Address = addr; qspi_command_struct.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE; qspi_command_struct.DummyCycles = 0; qspi_command_struct.DataMode = QSPI_DATA_4_LINES; qspi_command_struct.NbData = datalen; qspi_command_struct.DdrMode = QSPI_DDR_MODE_DISABLE; qspi_command_struct.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY; qspi_command_struct.SIOOMode = QSPI_SIOO_INST_EVERY_CMD; HAL_QSPI_Command(hqspi, qspi_command_struct, HAL_QSPI_TIMEOUT_DEFAULT_VALUE); HAL_QSPI_Transmit(hqspi, pbuf, HAL_QSPI_TIMEOUT_DEFAULT_VALUE); bsp_pm004mniatr.h文件 #ifndef __BSP_PM004MNIATR_H__#define __BSP_PM004MNIATR_H__#include stdint.h#include main.h#ifdef __cplusplusextern C #endif#define PM004MNIATR_MODE_REGISTER_1_ADDR 0x00#define PM004MNIATR_MODE_REGISTER_2_ADDR 0x01#define PM004MNIATR_MODE_REGISTER_3_ADDR 0x02#define PM004MNIATR_COMMAND_READ_ID 0x9F#define PM004MNIATR_COMMAND_ENTER_QSPI 0x35#define PM004MNIATR_COMMAND_EXIT_QSPI 0xF5#define PM004MNIATR_COMMAND_WRITE_ENABLE 0x06#define PM004MNIATR_COMMAND_WRITE_MODE_REGISTER 0xB1#define PM004MNIATR_COMMAND_READ_MODE_REGISTER 0xB5#define PM004MNIATR_COMMAND_WRITE_DATA 0x02#define PM004MNIATR_COMMAND_READ_DATA 0x03#define PM004MNIATR_COMMAND_ENTRY_SLEEP 0xB9#define PM004MNIATR_COMMAND_EXIT_SLEEP 0xAB#define PM004MNIATR_COMMAND_RESE_ENABLE 0x66#define PM004MNIATR_COMMAND_RESET 0x99void pm004mniatr_init(void);uint8_t pm004mniatr_read_sr(uint8_t addr);void pm004mniatr_write_sr(uint8_t addr, uint8_t byte);void pm004mniatr_read_data(uint32_t addr, uint8_t *pbuf, uint16_t datalen);void pm004mniatr_write_data(uint32_t addr, uint8_t *pbuf, uint16_t datalen);#ifdef __cplusplus#endif#endif\t/* __BSP_PM004MNIATR_H__ */ 欢迎关注本人微信公众号：","categories":["驱动"]},{"title":"RT-Thread之创建线程","path":"/RTOS/RT-Thread之创建线程/","content":"一、静态线程创建1、thread_task.c文件#include thread_task.h#include main.h#include stdio.h #include rtthread.h/******************************************** 线程 1 ******************************************************/#define THREAD_1_PRIORITY 5 /* 进程优先级 */#define THREAD_1_STACK_SIZE 512 /* 进程栈空间大小 */#define THREAD_1_TIMESLICE 1 /* 进程执行时间片个数 */static char thread_1_stack[THREAD_1_STACK_SIZE]; /* 进程栈 */static struct rt_thread thread_1_handle; /* 进程句柄 *//******************************************** 线程 2 ******************************************************/#define THREAD_2_PRIORITY 5 /* 进程优先级 */#define THREAD_2_STACK_SIZE 512 /* 进程栈空间大小 */#define THREAD_2_TIMESLICE 1 /* 进程执行时间片个数 */static char thread_2_stack[THREAD_1_STACK_SIZE]; /* 进程栈 */static struct rt_thread thread_2_handle; /* 进程句柄 */uint8_t count_1 = 0;uint8_t count_2 = 0;/** * @brief 线程1入口函数 * @param 无 * @retval 无 */void thread_1_entry(void* param) while(1) rt_tick_t now_tick = rt_tick_get(); /* 获取当前时间 */ HAL_GPIO_TogglePin(GPIOC, LED1_Pin); rt_thread_delay_until(now_tick, 1000); /* 精准延时1000时间片 */ /** * @brief 线程2入口函数 * @param 无 * @retval 无 */void thread_2_entry(void* param) while(1) rt_tick_t now_tick = rt_tick_get(); /* 获取当前时间 */ HAL_GPIO_TogglePin(GPIOC, LED2_Pin); rt_thread_delay_until(now_tick, 1000); /* 精准延时1000时间片 */ /** * @brief 创建线程任务并启动 * @param 无 * @retval 无 */void ThreadStart(void)\t/* 初始化静态线程*/\trt_thread_init( thread_1_handle, /* 线程句柄*/ thread_1, /* 线程句柄名称*/ thread_1_entry, /* 函数入口 */ RT_NULL, /* 入口函数参数 */ thread_1_stack[0], /* 线程栈地址 */ THREAD_1_STACK_SIZE,\t/* 线程栈大小 */ THREAD_1_PRIORITY, /* 线程优先级 */ THREAD_1_TIMESLICE);\t/* 线程时间片大小 */ rt_thread_startup(thread_1_handle); /* 启动线程 */\t/* 初始化静态线程*/\trt_thread_init( thread_2_handle, /* 线程句柄*/ thread_2, /* 线程句柄名称*/ thread_2_entry, /* 函数入口 */ RT_NULL, /* 入口函数参数 */ thread_2_stack[0], /* 线程栈地址 */ THREAD_2_STACK_SIZE,\t/* 线程栈大小 */ THREAD_2_PRIORITY, /* 线程优先级 */ THREAD_2_TIMESLICE);\t/* 线程时间片大小 */ rt_thread_startup(thread_2_handle); /* 启动线程 */ 2、thread_task.h文件#ifndef __THREAD_TASK_H#define __THREAD_TASK_H#ifdef __cplusplusextern C #endifvoid ThreadStart(void);#ifdef __cplusplus#endif#endif /* __THREAD_TASK_H */ 二、静态创建线程（自定义实现调度）1、thread_task.c文件#include thread_task.h#include main.h#include stdio.h #include rtthread.h/******************************************** 线程 1 ******************************************************/#define THREAD_1_CYCLE 1000 /* 进程执行周期 */#define THREAD_1_PRIORITY 5 /* 进程优先级 */#define THREAD_1_STACK_SIZE 512 /* 进程栈空间大小 */#define THREAD_1_TIMESLICE 1 /* 进程执行时间片个数 */static char thread_1_stack[THREAD_1_STACK_SIZE]; /* 进程栈 */static struct rt_thread thread_1_handle; /* 进程句柄 *//******************************************** 线程 2 ******************************************************/#define THREAD_2_CYCLE 1000 /* 进程执行周期 */#define THREAD_2_PRIORITY 5 /* 进程优先级 */#define THREAD_2_STACK_SIZE 512 /* 进程栈空间大小 */#define THREAD_2_TIMESLICE 1 /* 进程执行时间片个数 */static char thread_2_stack[THREAD_1_STACK_SIZE]; /* 进程栈 */static struct rt_thread thread_2_handle; /* 进程句柄 */uint8_t count_1 = 0;uint8_t count_2 = 0;/** * @brief 线程1入口函数 * @param 无 * @retval 无 */void thread_1_entry(void* param) while(1) HAL_GPIO_TogglePin(GPIOC, LED1_Pin); rt_thread_suspend(thread_1_handle); //挂起线程 rt_schedule(); //启动调度器 /** * @brief 线程2入口函数 * @param 无 * @retval 无 */void thread_2_entry(void* param) while(1) HAL_GPIO_TogglePin(GPIOC, LED2_Pin); rt_thread_suspend(thread_2_handle); //挂起线程 rt_schedule(); //启动调度器 /** * @brief 创建线程任务并启动 * @param 无 * @retval 无 */void ThreadStart(void)\t/* 初始化静态线程*/\trt_thread_init( thread_1_handle, /* 线程句柄*/ thread_1, /* 线程句柄名称*/ thread_1_entry, /* 函数入口 */ RT_NULL, /* 入口函数参数 */ thread_1_stack[0], /* 线程栈其实地址 */ THREAD_1_STACK_SIZE,\t/* 线程栈大小 */ THREAD_1_PRIORITY, /* 线程优先级 */ THREAD_1_TIMESLICE);\t/* 线程时间片大小 */ rt_thread_startup(thread_1_handle); /* 启动线程 */\t/* 初始化静态线程*/\trt_thread_init( thread_2_handle, /* 线程句柄*/ thread_2, /* 线程句柄名称*/ thread_2_entry, /* 函数入口 */ RT_NULL, /* 入口函数参数 */ thread_2_stack[0], /* 线程栈其实地址 */ THREAD_2_STACK_SIZE,\t/* 线程栈大小 */ THREAD_2_PRIORITY, /* 线程优先级 */ THREAD_2_TIMESLICE);\t/* 线程时间片大小 */ rt_thread_startup(thread_2_handle); /* 启动线程 *//*任务调度*/void Task_Schedule(void)\tstatic uint32_t task_count = 0;\tif(task_count%1000 == 0) rt_thread_resume(thread_1_handle);\tif(task_count%2000 == 0) rt_thread_resume(thread_2_handle); rt_schedule();\ttask_count++; //计数值达到一定值后清零，防止任务调度错乱\tif(task_count == 200000)\ttask_count = 0; 2、thread_task.h文件#ifndef __THREAD_TASK_H#define __THREAD_TASK_H#ifdef __cplusplusextern C #endifvoid ThreadStart(void);void Task_Schedule(void);#ifdef __cplusplus#endif#endif /* __THREAD_TASK_H */ 2、修改board.c中的SysTick_Handler()函数extern void Task_Schedule(void);void SysTick_Handler(void) /* 进入中断 */ rt_interrupt_enter(); /* 更新时基 */ rt_tick_increase(); /* 自定义调度函数 */ Task_Schedule(); /* 离开中断 */ rt_interrupt_leave(); 三、动态创建线程1、thread_task.c文件#include thread_task.h#include main.h#include stdio.h #include rtthread.h/******************************************** 线程 1 ******************************************************/#define THREAD_1_PRIORITY 5 /* 进程优先级 */#define THREAD_1_STACK_SIZE 512 /* 进程栈空间大小 */#define THREAD_1_TIMESLICE 1 /* 进程执行时间片个数 */static struct rt_thread *thread_1_handle; /* 进程句柄 *//******************************************** 线程 2 ******************************************************/#define THREAD_2_PRIORITY 5 /* 进程优先级 */#define THREAD_2_STACK_SIZE 512 /* 进程栈空间大小 */#define THREAD_2_TIMESLICE 1 /* 进程执行时间片个数 */static struct rt_thread *thread_2_handle; /* 进程句柄 *//** * @brief 线程1入口函数 * @param 无 * @retval 无 */void thread_1_entry(void* param) while(1) rt_tick_t now_tick = rt_tick_get(); /* 获取当前时间 */ HAL_GPIO_TogglePin(GPIOC, LED1_Pin); rt_thread_delay_until(now_tick, 1000); /* 精准延时1000时间片 */ /** * @brief 线程2入口函数 * @param 无 * @retval 无 */void thread_2_entry(void* param) while(1) rt_tick_t now_tick = rt_tick_get(); /* 获取当前时间 */ HAL_GPIO_TogglePin(GPIOC, LED2_Pin); rt_thread_delay_until(now_tick, 1000); /* 精准延时1000时间片 */ /** * @brief 动态创建线程任务并启动 * @param 无 * @retval 无 */void ThreadStart(void) /* 动态创建线程 */ thread_1_handle = rt_thread_create( thread_1, /* 线程句柄名称*/ thread_1_entry, /* 函数入口 */ RT_NULL, /* 入口函数参数 */ THREAD_1_STACK_SIZE,\t/* 线程栈大小 */ THREAD_1_PRIORITY, /* 线程优先级 */ THREAD_1_TIMESLICE /* 线程时间片大小 */ ); rt_thread_startup(thread_1_handle); /* 启动线程 */ thread_2_handle = rt_thread_create( thread_2, /* 线程句柄名称*/ thread_2_entry, /* 函数入口 */ RT_NULL, /* 入口函数参数 */ THREAD_2_STACK_SIZE,\t/* 线程栈大小 */ THREAD_2_PRIORITY, /* 线程优先级 */ THREAD_2_TIMESLICE /* 线程时间片大小 */ ); rt_thread_startup(thread_2_handle); /* 启动线程 */ 2、thread_task.h文件#ifndef __THREAD_TASK_H#define __THREAD_TASK_H#ifdef __cplusplusextern C #endifvoid ThreadStart(void);void Task_Schedule(void);#ifdef __cplusplus#endif#endif /* __THREAD_TASK_H */","tags":["RT-Thread"],"categories":["RTOS"]},{"title":"STM32之使用DWT外设编写延时函数","path":"/MCU开发/STM32之使用DWT外设编写延时函数/","content":"WT 是一个调试外设，它的核心功能之一是 CYCCNT（Cycle Count），这是一个32位递增计数器，用于记录 CPU 执行的时钟周期数量。我们可以通过对这个计数器的变化来实现高精度延时。 在使用 DWT 延时之前，需要完成以下操作： 使能 DWT 使能 CYCCNT 清零 CYCCNT 基于 CYCCNT 实现延时逻辑 源码如下： dwt.delay.h文件 #ifndef __DWT_DELAY_H#define __DWT_DELAY_H#include stm32g4xx.h/* 获取内核时钟频率 */#define GET_CPU_ClkFreq() HAL_RCC_GetSysClockFreq()uint32_t CPU_TS_TmrRd(void);HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority);//最大延时值为8秒void dwt_delay_us(uint32_t us);#define HAL_Delay(ms) dwt_delay_us(ms*1000) #define dwt_delay_s(s) dwt_delay_us(s*1000000)#endif /* __DWT_DELAY_H */ dwt_delay.c文件 #include dwt_delay.h#define DWT_CR *(__IO uint32_t *)0xE0001000#define DWT_CYCCNT *(__IO uint32_t *)0xE0001004#define DEM_CR *(__IO uint32_t *)0xE000EDFC#define DEM_CR_TRCENA (1 24)#define DWT_CR_CYCCNTENA (1 0)/*** @brief 初始化时间戳* @param 无* @retval 无* @note 使用延时函数前，必须调用本函数*/HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority) /* 使能DWT外设 */ DEM_CR |= (uint32_t)DEM_CR_TRCENA; /* DWT CYCCNT寄存器计数清0 */ DWT_CYCCNT = (uint32_t)0u; /* 使能Cortex-M DWT CYCCNT寄存器 */ DWT_CR |= (uint32_t)DWT_CR_CYCCNTENA; return HAL_OK;/*** @brief 读取当前时间戳,每1ms更新一次* @param 无* @retval ms时间戳*/uint32_t HAL_GetTick(void) return ((uint32_t)DWT_CYCCNT/(GET_CPU_ClkFreq()*1000));/*** @brief 采用CPU的内部计数实现精确延时，32位计数器，最大延时时间8秒* @param us : 延迟长度，单位1 us* @retval 无*/void dwt_delay_us(uint32_t us) uint32_t ticks; uint32_t told,tnow,tcnt=0; ticks = us * (GET_CPU_ClkFreq() / 1000000); /* 需要的节拍数 */ tcnt = 0; told = (uint32_t)DWT_CYCCNT; /* 刚进入时的计数器值 */ while(1) tnow = (uint32_t)DWT_CYCCNT; if(tnow != told) if(tnow told) tcnt += tnow - told; else /* 重新装载 */ tcnt += UINT32_MAX - told + tnow; told = tnow; /*时间超过/等于要延迟的时间,则退出 */ if(tcnt = ticks)break;","tags":["STM32"],"categories":["MCU开发"]},{"title":"ASCII表格生成器","path":"/上位机开发/ASCII表格生成器/","content":"在写代码时有时要在代码中插入表格，手写太麻烦，所以使用 Python 的 Tkinter 开发了一个功能齐全、可自定义的 ASCII 表格生成器上位机工具。 一、效果展示1、在文本中的效果：┌────────────────────────────────────────────┐│ DW3000 寄存器映射表 │├────────────────────────────────────────────┤│ addr │ name │ width │├──────────┼─────────────────┼───────────────┤│ 0x00 │ DEV_ID │ 32-bit ││ 0x12 │ RX_BUFFER_0 │ 1024-byte │└────────────────────────────────────────────┘ 2、上位机界面效果： 二、操作1、直接使用exe文件百度网盘链接如下： 通过网盘分享的文件：ASCII表格生成器链接: https://pan.baidu.com/s/1GY5-F0Ha-sWsSDttyw6aCw?pwd=kcy4 提取码: kcy4 --来自百度网盘超级会员v5的分享 2、使用源码编译方法（源码见附录）首先安装Python，执行以下指令安装所需要的python库： // 安装GUI库pip install sv_ttk -i https://pypi.tuna.tsinghua.edu.cn/simple/// 安装打包所需要的库pip install sv_ttk -i https://pypi.tuna.tsinghua.edu.cn/simple/ 执行打包命令： // 其中my.ico为应用图标pyinstaller -F -w -i my.ico --hidden-import numpy tool.py 三、附录：1、源码import tkinter as tkfrom tkinter import ttk, messagebox, scrolledtextimport sv_ttkimport reclass PerfectAsciiTableGenerator: def __init__(self, root): self.root = root self.root.title(ASCII表格生成器-LSK) self.root.geometry(800x600) # 应用Sun Valley主题 sv_ttk.set_theme(light) # 创建主框架 self.main_frame = ttk.Frame(root, padding=10) self.main_frame.pack(fill=tk.BOTH, expand=True) # 标题部分 self.title_frame = ttk.LabelFrame(self.main_frame, text=表格设置, padding=10) self.title_frame.pack(fill=tk.X, pady=(0, 10)) ttk.Label(self.title_frame, text=表格标题:).grid(row=0, column=0, sticky=tk.W) self.title_entry = ttk.Entry(self.title_frame, width=50) self.title_entry.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W) self.title_entry.insert(0, DW3000 寄存器映射表) # 数据部分 self.data_frame = ttk.LabelFrame(self.main_frame, text=表格数据, padding=10) self.data_frame.pack(fill=tk.BOTH, expand=True) ttk.Label(self.data_frame, text=第一行为表头，用制表符或空格分隔列:).pack(anchor=tk.W) self.data_text = scrolledtext.ScrolledText(self.data_frame, height=10) self.data_text.pack(fill=tk.BOTH, expand=True) # 设置示例数据 example_data = addr\\tname\\twidth0x00\\tDEV_ID\\t32-bit0x12\\tRX_BUFFER_0\\t1024-byte self.data_text.insert(tk.END, example_data) # 按钮部分 self.button_frame = ttk.Frame(self.main_frame) self.button_frame.pack(fill=tk.X, pady=(10, 0)) self.generate_btn = ttk.Button(self.button_frame, text=生成表格, command=self.generate_table) self.generate_btn.pack(side=tk.LEFT, padx=5) self.copy_btn = ttk.Button(self.button_frame, text=复制, command=self.copy_to_clipboard) self.copy_btn.pack(side=tk.LEFT, padx=5) # 结果部分 self.result_frame = ttk.LabelFrame(self.main_frame, text=生成的表格, padding=10) self.result_frame.pack(fill=tk.BOTH, expand=True) self.result_text = scrolledtext.ScrolledText(self.result_frame, height=15) self.result_text.pack(fill=tk.BOTH, expand=True) self.result_text.config(state=tk.DISABLED) def generate_table(self): try: # 获取输入数据 title = self.title_entry.get() lines = [line.strip() for line in self.data_text.get(1.0, tk.END).split( ) if line.strip()] if not lines: raise ValueError(请输入至少一行数据) # 自动识别分隔符 if any(\\t in line for line in lines): sep = \\t else: sep = # 解析数据 rows = [re.split(r[\\t ]+, line.strip()) for line in lines] headers = rows[0] data_rows = rows[1:] if len(rows) 1 else [] # 检查列数一致性 col_count = len(headers) for i, row in enumerate(rows, 1): if len(row) != col_count: raise ValueError(f第 i 行列数不一致，应为 col_count 列，但找到 len(row) 列) # 生成表格 table = self._create_perfect_table(title, headers, data_rows) # 显示结果 self.result_text.config(state=tk.NORMAL) self.result_text.delete(1.0, tk.END) self.result_text.insert(tk.END, table) self.result_text.config(state=tk.DISABLED) except Exception as e: messagebox.showerror(错误, f生成表格时出错: str(e)) def _create_perfect_table(self, title, headers, data): borders = tl: ┌, tr: ┐, # 顶角 bl: └, br: ┘, # 底角 h: ─, v: │, # 水平/垂直线 lt: ├, rt: ┤, # 左右连接 c: ┼ # 交叉 # 计算每列宽度（内容+6保证两侧各3空格） col_widths = [ max(max(len(str(item)) for item in col) + 6, 7) # 最小宽度为7 for col in zip(headers, *data) ] # 计算总宽度（列宽之和 + 列间垂直线） total_width = sum(col_widths) + (len(col_widths) - 1) lines = [] # 1. 顶部边框 top_line = borders[tl] + borders[h] * total_width + borders[tr] lines.append(top_line) # 2. 标题行 if title: title_line = borders[v] + title.center(total_width) + borders[v] lines.append(title_line) # 3. 表头分隔线 hline = borders[lt] for i, w in enumerate(col_widths): hline += borders[h] * w hline += borders[h] if i len(col_widths)-1 else borders[rt] lines.append(hline) # 4. 表头行 header_line = borders[v] for i, (header, w) in enumerate(zip(headers, col_widths)): header_line += str(header).center(w) header_line += borders[v] if i len(headers)-1 else borders[v] lines.append(header_line) # 5. 数据分隔线（带交叉） dline = borders[lt] for i, w in enumerate(col_widths): dline += borders[h] * w dline += borders[c] if i len(col_widths)-1 else borders[rt] lines.append(dline) # 6. 数据行 for row in data: row_line = borders[v] for i, (item, w) in enumerate(zip(row, col_widths)): row_line += str(item).center(w) row_line += borders[v] if i len(row)-1 else borders[v] lines.append(row_line) # 7. 底部边框 bottom_line = borders[bl] for i, w in enumerate(col_widths): bottom_line += borders[h] * w bottom_line += borders[h] if i len(col_widths)-1 else borders[br] lines.append(bottom_line) return .join(lines) def copy_to_clipboard(self): 将生成的表格复制到剪贴板 table = self.result_text.get(1.0, tk.END).strip() if table: self.root.clipboard_clear() self.root.clipboard_append(table) messagebox.showinfo(成功, 表格已复制到剪贴板!) else: messagebox.showwarning(警告, 没有可复制的内容!)if __name__ == __main__: root = tk.Tk() app = PerfectAsciiTableGenerator(root) root.mainloop()# pyinstaller -F -w -i my.ico --hidden-import numpy tool.py 欢迎关注微信公众号：","tags":["tkinter"],"categories":["上位机开发"]},{"title":"RT-Thread Nano源码浅析","path":"/RTOS/RT-Thread Nano源码浅析/","content":"一、了解源码从官方下载到RT-Thread Nano源码目录如下图所示 ![RT源码文件夹](D:\\个人文档\\blog\\RT-Thread Nano源码浅析\\RT源码文件夹.png) 1、bsp文件夹bsp文件夹里面存放的是板级支持包（board support package），用于存放RT-Thread为各种半导体厂商的评估板写好的驱动程序，其中重要的主要是两个文件 board.c：RT-Thread用来初始化开发板硬件的相关函数； rtconfig.h：RT-Thread功能的配置头文件，可以裁剪RT-Thread的功能； 2、components文件夹其它第三方加进来的组件，比如gui、fatfs、lwip和finsh等。nano版本只放了finsh，是RT- Thread组件里面最具特色的，它通过串口打印的方式来输出各种信息，方便我们调试程序。 3、docs文件夹其他文件 4、include文件夹include目录下面存放的是RT-Thread内核的头文件，是内核不可分割的一部分。 5、libcpu文件夹存放软件和硬件的接口文件，通常由汇编和C联合编写。 6、src文件夹src目录下面存放的是RT-Thread内核的源文件，是内核的核心 二、官方移植1、修改board.c文件/* * Copyright (c) 2006-2019, RT-Thread Development Team * * SPDX-License-Identifier: Apache-2.0 * * Change Logs: * Date Author Notes * 2021-05-24 the first version */#include rthw.h#include rtthread.h#include main.h#if defined(RT_USING_USER_MAIN) defined(RT_USING_HEAP)/* * Please modify RT_HEAP_SIZE if you enable RT_USING_HEAP * the RT_HEAP_SIZE max value = (sram size - ZI size), 1024 means 1024 bytes */#define RT_HEAP_SIZE (15*1024)static rt_uint8_t rt_heap[RT_HEAP_SIZE];RT_WEAK void *rt_heap_begin_get(void) return rt_heap;RT_WEAK void *rt_heap_end_get(void) return rt_heap + RT_HEAP_SIZE;#endifvoid SysTick_Handler(void) /* 进入中断 */ rt_interrupt_enter(); /* 更新时基 */ rt_tick_increase(); /* 离开中断 */ rt_interrupt_leave();/** * This function will initial your board. */void rt_hw_board_init(void) /* 添加HAL初始化、时钟配置、滴答时钟配置 */ extern void SystemClock_Config(void); HAL_Init(); SystemClock_Config(); SystemCoreClockUpdate(); HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/RT_TICK_PER_SECOND); /* Call components board initial (use INIT_BOARD_EXPORT()) */#ifdef RT_USING_COMPONENTS_INIT rt_components_board_init();#endif#if defined(RT_USING_USER_MAIN) defined(RT_USING_HEAP) rt_system_heap_init(rt_heap_begin_get(), rt_heap_end_get());#endif#ifdef RT_USING_CONSOLEstatic int uart_init(void)#error TODO 2: Enable the hardware uart and config baudrate. return 0;INIT_BOARD_EXPORT(uart_init);void rt_hw_console_output(const char *str)#error TODO 3: Output the string str through the uart.#endif 2、修改rtconfig.h文件#ifndef __RTTHREAD_CFG_H__#define __RTTHREAD_CFG_H__/*----------------------------------------------------------------------------*//* 配置启用标志（一般用 #define 或 #undef） *//* 表示RT-Thread支持libc函数（标准库） */#define RT_USING_LIBC/* 表示RT-Thread支持的最大优先级数目，取值范围为8-256，默认为32 */#define RT_THREAD_PRIORITY_MAX 8/* 表示操作系统每秒的 tick 数，系统时钟周期为 1ms */#define RT_TICK_PER_SECOND 1000/*----------------------------------------------------------------------------*//* 内核配置选项（一般用 #define 或 #undef） *//* CPU 数据对齐字节数，默认为 4 */#define RT_ALIGN_SIZE 4/* 内核对象名称最大长度，默认为 8 */#define RT_NAME_MAX 8/* 使用 RT-Thread 组件初始化，启用 */#define RT_USING_COMPONENTS_INIT/* 使用用户 main 函数，启用 */#define RT_USING_USER_MAIN/*----------------------------------------------------------------------------*//* 线程配置（main 线程） *//* main 线程栈大小，默认为 512 */#define RT_MAIN_THREAD_STACK_SIZE 256/*----------------------------------------------------------------------------*//* 调试配置 *//* 内核调试启用（建议设为 0） *///#define RT_DEBUG/* 初始化调试启用（默认关闭） */#define RT_DEBUG_INIT 0/* 线程栈溢出检查启用 *///#define RT_USING_OVERFLOW_CHECK/*----------------------------------------------------------------------------*//* 钩子配置（用于调试，可选） *//* 钩子函数启用 *///#define RT_USING_HOOK/* 空闲线程钩子启用 *///#define RT_USING_IDLE_HOOK/*----------------------------------------------------------------------------*//* 定时器配置（可选） *//* 使用软件延时（默认关闭） */#define RT_USING_TIMER_SOFT 0#if RT_USING_TIMER_SOFT == 0 #undef RT_USING_TIMER_SOFT#endif#define RT_TIMER_THREAD_PRIO 4#define RT_TIMER_THREAD_STACK_SIZE 512/*----------------------------------------------------------------------------*//* 内部通信配置，包括信号量、互斥量、事件、邮箱和消息队列，根据需要配置 *///#define RT_USING_SEMAPHORE /* 信号量*///#define RT_USING_MUTEX /* 互斥量 *///#define RT_USING_EVENT /* 事件 *///#define RT_USING_SIGNALS /* 信号 */ //#define RT_USING_MAILBOX /* 邮箱 *///#define RT_USING_MESSAGEQUEUE /* 消息队列 *//*----------------------------------------------------------------------------*//* 内存配置（可选） *//* 是否使用内存池 *///#define RT_USING_MEMPOOL/* 是否使用动态内存堆 *///#define RT_USING_HEAP/* 是否使用小内存 *///#define RT_USING_SMALL_MEM#define RT_USING_SMALL_MEM_AS_HEAP/* 示是否使用极小内存 *///#define RT_USING_TINY_SIZE/*----------------------------------------------------------------------------*//* 控制台配置（用于调试输出） *//* 是否使用控制台（调试接口） *///#define RT_USING_CONSOLE/* 控制台缓冲区大小，默认为 256 */#define RT_CONSOLEBUF_SIZE 256/*----------------------------------------------------------------------------*//* 驱动与设备配置（可选） *//* 使用设备驱动接口 *///#define RT_USING_DEVICE/*----------------------------------------------------------------------------*//* 系统启动与运行配置（可选） *//* 控制台提供 FINSH 命令行支持 *///#include finsh_config.h#endif","categories":["RTOS"]},{"title":"STM32之GPIO输出","path":"/MCU开发/STM32之GPIO输出/","content":"在 STM32 的开发中，GPIO（通用输入输出）是一种极其重要且常用的外设资源。无论是用于控制 LED、按键、电机驱动，还是与其他外设之间通信，GPIO 都是实现这些功能的核心接口。 一、示例代码这是一个在 STM32 HAL 库中非常常见的初始化函数，用于配置 GPIO 引脚为输出模式，并设置相应的参数。 /** * @brief 初始化GPIO引脚（用于LED控制） * @param 无 * @retval 无 */void GPIO_Init(void) /* 初始化GPIO结构体，所有成员默认为0 */ GPIO_InitTypeDef GPIO_InitStruct = 0; /* 使能 GPIO 端口时钟 */ __HAL_RCC_GPIOC_CLK_ENABLE(); __HAL_RCC_GPIOF_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); /* 设置GPIOC端口上LED1、LED2、LED3引脚初始状态为高电平 */ HAL_GPIO_WritePin(GPIOC, LED1_Pin|LED2_Pin|LED3_Pin, GPIO_PIN_SET); GPIO_InitStruct.Pin = LED1_Pin | LED2_Pin | LED3_Pin; /* 设置GPIO引脚属性：选择LED1、LED2、LED3引脚 */ GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; /* 设置工作模式为推挽输出 */ GPIO_InitStruct.Pull = GPIO_PULLUP; /* 设置内部上拉电阻 */ GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; /* 设置输出速度为低速 */ HAL_GPIO_Init(GPIOC, GPIO_InitStruct); /* 初始化GPIO引脚，传入端口地址和配置结构体 */ 二、GPIO_InitStruct参数配置1、GPIO_InitStruct.Pin选择要配置的引脚 2、 GPIO_InitStruct.Mode设置 GPIO 引脚的 工作模式。 推挽输出（Output Push Pull） 输入参数：GPIO_MODE_OUTPUT_PP 描述：引脚输出低或高电平，有驱动能力，适用于驱动负载 场景：LED、数码管、外部电路驱动 开漏输出（Output Open Drain） 输入参数：GPIO_MODE_OUTPUT_OD 描述：输出高电平由外部上拉电阻决定，输出低电平由内部施放 场景：可能用于 I2C、逻辑总线 复用推挽输出 输入参数：GPIO_MODE_OUTPUT_PP 描述：GPIO_MODE_OUTPUT_AF_PP 场景：SPI、I2C、UART 通信接口 复用开漏输出 输入参数：GPIO_MODE_OUTPUT_AF_OD 描述：用于通信协议（如 SPI、UART、I2C）等，信号链路由外部上拉 场景：需要外部上拉的通信协议 3、GPIO_InitStruct.Pull设置 GPIO 引脚的 上拉或下拉电阻。 启用上拉电阻 输入参数：GPIO_PULLUP 描述：默认状态为高电平，适用于按钮、传感器等 启用下拉电阻 输入参数：GPIO_PULLUP 描述：默认状态为低电平 无上下拉 输入参数：GPIO_NOPULL 描述：不自动上拉或下拉引脚 4、GPIO_InitStruct.Speed设置 GPIO 引脚工作速度 低速 输入参数：GPIO_SPEED_FREQ_LOW 描述：最高5MHz 中速 输入参数：GPIO_SPEED_FREQ_MEDIUM 描述：5MHz ~ 25MHz 高速 输入参数：GPIO_SPEED_FREQ_HIGH 描述：25MHz ~ 50MHz 极高速 输入参数：GPIO_SPEED_FREQ_VERY_HIGH 描述：50MHz ~ 120MHz","tags":["STM32"],"categories":["MCU开发"]},{"title":"CAN通讯协议","path":"/通讯协议/CAN通讯协议/","content":"CAN通讯是一种多主总线异步通信协议，采用差分信号传输，具有高可靠性、实时性强、抗干扰能力好等特点。它广泛应用于汽车电子、工业控制等领域，用于设备间数据快速准确传输，保障系统稳定运行。 一、CAN物理层1、电气特性 ​ 总线结构物理特征如下图所示（左：闭环；右：开环） CAN总线由两根信号线组成，使用的是差分信号，是一种异步通讯CAN总线网络的结构有闭环和开环两种，其对应标准分别在**ISO11898（高速CAN标准）和ISO11519-2（低速CAN）**中描述（对OSI七层模型中的数据链路层和物理层进行了标准化），两种标准对比如下图所示： 2、CAN的电平形式CAN是差分通讯，总线电平分为显性电平(Dominant Level)和隐形电平(Recessive Level)两种，总线必须处于两种电平之一，总线上执行逻辑上的线与时，显性电平为0，隐形电平为1 二、CAN总线帧格式 帧类型 用途 数据帧 发送设备主动发送数据（广播式） 遥控帧 接收设备主动请求数据（请求式） 错误帧 某个设备检测出错误时向其他设备通知错误 过载帧 接收设备通知其尚未做好接收准备 间隔帧 用于将数据帧及遥控帧与前面的帧分离开 1、数据帧 帧起始（标准扩展格式相同） SOF（Start of Frame）：帧起始，一个显性位，表示帧开始的段； 仲裁段（标准扩展格式不同） ID（Identify）： 仲裁段，区分功能，同时决定优先级； 标准CAN有11位ID（ID28-ID18），扩展格式ID包含基本ID（ID28-ID18）和扩展ID（ID17-ID0）； 禁止高7为ID全为1（隐形）； （标准ID）RTR（Remote Transmission Request ）：远程请求位，区分数据帧和遥控帧； （扩展ID）IDE（Identifier Extension）：扩展标志位，区分标准格式和扩展格式； （扩展ID）SRR（Substitute Remote Request）：替代RTR，协议升级时留下的无意义位； 控制段（标准扩展格式不同） r0/r1（Reserve）：保留位，为后续协议升级留下空间； DLC（Data Length Code）：数据长度，指示数据段有几个字节； （标准ID）IDE（Identifier Extension）：扩展标志位，区分标准格式和扩展格式； 数据段（标准扩展格式相同） Data：数据段，0~8个字节； CRC段（标准扩展格式相同） CRC（Cyclic Redundancy Check）：15位循环冗余校验，校验数据是否正确； CRC界定符：1隐性位 ACK段（标准扩展格式相同） ACK（ACK Slot）：应答槽位，发送方发送1（隐形），接收方回应0（显性），判断数据有没有被接收方接收； ACK界定符：1隐性位 帧结束（标准扩展格式相同） EOF（End of Frame ）：帧结束，7位隐形位，表示数据位已经传输完毕； 2、遥控帧遥控帧无数据段，RTR为隐性电平1，其他部分与数据帧相同 img srcCAN通讯协议\\image-20250703003936526.png” alt”image-20250703003936526” style”zoom:67%;” 3、错误帧总线上所有设备都会监督总线的数据，一旦发现“位错误”或“填充错误”或“CRC错误”或“格式错误”或“应答错误” ，这些设备便会发出错误帧来破坏数据，同时终止当前的发送设备。 4、过载帧当接收方收到大量数据而无法处理时，其可以发出过载帧，延缓发送方的数据发送，以平衡总线负载，避免数据丢失。 5、帧间隔将数据帧和遥控帧与前面的帧分离开 四、位时序由发送单元在非同步的情况下发送的每秒钟的位数称为位速率。一个位可分为4段，它们都由**Time Quantum(Tq)**的最小时间的那位组成。 同步段（SS） 传播时间段（PTS） 相位缓冲段1（PBS1） 相位缓冲段2（PBS2） 1 位分为 4 个段，每个段又由若干个 Tq 构成，这称为位时序。 其中采样点位于PBS1结束后 段及其作用如下图所示： 五、波特率的计算$$baud\\ rate\\frac{1}{T_{ss}+T_{PTS}+T_{PBS1}+T_{PBS2}}$$ 其中每一个段的时间由Tq组成，Tq 1CAN时钟频率； 六、位填充位填充是为防止突发错误而设定的功能。当同样的电平持续5位时则添加一个位的反型数据。如下图所示： 1、发送单元的工作在发送数据帧和遥控帧时，SOF～CRC段间的数据，相同电平如果持续5位，在下一个位（第6个位）则要插入1位与前5位反型的电平。 2、接收单元的工作在接收数据帧和遥控帧时，SOF～CRC段间的数据，相同电平如果持续5位，需要删除下一个位（第6个位）再接收。如果这个第6个位的电平与前5位相同，将被视为错误并发送错误帧。 七、附录1、数据长度码和字节关系","tags":["CAN"],"categories":["通讯协议"]},{"title":"conda使用","path":"/工具使用/conda使用/","content":"创建虚拟环境# 创建名为env_name的虚拟环境conda create --name env_name# 创建名为env_name的虚拟环境，指定python版本conda create --name env_name python=3.8# 创建指定python版本下包含某些包的env_name虚拟环境conda create --name env_name python=3.6 pandas numpy scipy 查看所有虚拟环境conda info --envs# 或者conda env list 退出当前虚拟环境deactivate 激活进入虚拟环境activate env_name 删除某一虚拟环境conda remove --name env_name --all 查看当前虚拟环境下的所有的安装包conda list #需进入该虚拟环境conda list -n env_name 安装或卸载包(进入虚拟环境之后）conda install requestsconda install xx=版本号 # 指定版本号conda install xxx -i 源名称或链接 # 指定下载源conda uninstall xxx 分享虚拟环境conda env export environment.yml # 导出当前虚拟环境conda env create -f environment.yml # 创建保存的虚拟环境 源服务器管理#查看当前使用源conda config --show-sources #删除指定源conda config --remove channels#添加指定源conda config --add channels #例子conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ pip源阿里云 http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/豆瓣(douban) http://pypi.douban.com/simple/清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/","tags":["conda"],"categories":["工具使用"]},{"title":"pyqt环境搭建","path":"/pyQt/pyqt环境搭建/","content":"1、添加源服务器conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ 2、创建运行环境# 创建虚拟环境conda create --name pyqt6-python3.8 python=3.8 # 激活环境conda activate pyqt6-python3.8# 安装PyQt6pip install PyQt6 -i https://pypi.tuna.tsinghua.edu.cn/simple/# 安装PyQt6-toolspip install PyQt6-tools -i https://pypi.tuna.tsinghua.edu.cn/simple/ 3、vscode安装PYQT Integration插件# pyuic6D:\\RJ\\Miniconda\\envs\\pyqt6-python3.8\\Scripts\\pyuic6.exe# Path of Qt designerD:\\RJ\\Miniconda\\envs\\pyqt6-python3.8\\Lib\\site-packages\\qt6_applications\\Qt\\bin\\designer.exe","tags":["envs"],"categories":["pyQt"]},{"title":"嵌入式C语言寄存器操作","path":"/再探C语言/嵌入式C语言寄存器操作/","content":"一、常用寄存器操作/* 设置位 (置1)\t*/*pReg |= (1 bit_position);/* 清除位 (置0) */*pReg = ~(1 bit_position);/* 取反 */*pReg ^= (1 bit_position); 二、寄存器写操作如下所示为配置Pc13引脚为输出模式的错误示例： /* 配置为通用输出 * 00:Input mode * 01:General purpose output mode * 10:Alternate function mode * 11:Analog mode(reset state)*/pReg = (uint32_t *)(0x48000800 + 0x00);*pReg |= 0x01 26; 默认配置为为11,上述操作只修改了第二位，第一位未修改，导致配置错误，正确配置如下： /* 配置为通用输出 */pReg = (uint32_t *)(0x48000800 + 0x00);*pReg = ~(0x03 26);*pReg |= 0x01 26; 上述配置仍存在一定的安全问题，在对寄存器进行操作时，我们一定要遵守:读-改-写的步骤： / 单次读-修改-写保证原子性uint32_t temp = *pReg;temp = ~(0x03 26); // 清除MODER13区域temp |= 0x01 26; // 设为输出模式*pReg = temp;","tags":["寄存器"],"categories":["再探C语言"]},{"title":"STM32H750存储器映射","path":"/MCU开发/STM32H750存储器映射/","content":"STM32H750 是 ST 基于 Cortex-M7 内核的高性能 MCU，其复杂的 存储器架构 和 多总线矩阵 为开发者提供了极高的灵活性，但也带来了学习难度。深入了解STM32存储器映射和物理内存布局，了解不同存储区域的用途与性能差异，对于我们实际开发，如bootloader程序编写、MPU配置、链接脚本等，有着巨大帮助。 一、存储器映射STM32是一个32为单片机，它可以很方便访问4GB以内的存储空间，存储器本身是没有地址信息的，对存储器分配地址的过程就叫存储器映射。ST将所有的存储器及外设资源都映射在一个4GB的地址空间上（8个块)，从而可以通过访问对应的地址，访问具体的外设。其映射关系如下图所示: STM32H750存储器映射二、Block 0 地址范围 功能 0x0000 0000 ~ 0x0000 FFFF ITCM RAM，只能被CPU和MDMA 访问，属于高速的RAM 0x0001 0000 ~ 0x000F FFFF 保留 0x0010 0000 ~ 0x0010 EDBF 系统存储器，用于存储STM32出厂固化的Bootloader程序 0x0011 0000 ~ 0x001F FFFF 保留 0x0020 0000 ~ 0x003F FFFF FLASH 存储基于ITCM总线接口，不支持写操作，即只读。 0x0040 0000 ~ 0x07FF FFFF 保留 0x0800 0000 ~ 0x0801 FFFF 用户FLASH，用于存储用户代码 0x0802 0000 ~ 0x1FFF EFFF 保留 0x1FFF 0000 ~ 0x1FFF 001F 16个字节用于锁定对应的OTP数据块 0x1FFF 0020 ~ 0x1FFF FFFF 保留 三、Block 1 地址范围 功能 0x2000 0000 ~ 0x2001 FFFF DTCM RAM 0x2400 0000 ~ 0x2407 FFFF AXI SRAM 0x3000 0000 ~ 0x3001 FFFF SRAM1 0x3002 0000 ~ 0x3003 FFFF SRAM2 0x3004 0000 ~ 0x3004 7FFF SRAM3 0x3800 0000 ~ 0x3800 FFFF SRAM4 0x3880 0000 ~ 0x3880 0FFF Backup SRAM DTCM RAM，用于数据存取，特点是速度很快，和内核一样。 AXI SRAM，位于D1域，数据带宽是64bit，挂在AXI总线上。 SRAM1，SRAM2和SRAM3区，位于D2域，数据带宽是32bit，挂在AHB总线上。 SRAM1：用于D2域中的DMA缓冲，也可以当D1域断电后用于运行程序代码。 SRAM2：用于D2域中的DMA缓冲 ，也可以用于用户数据存取。 SRAM3：主要用于以太网和USB的缓冲。 SRAM4：位于D3域，数据带宽是32bit，挂在AHB总线上。可以用于D3域中的DMA缓冲， ​ 也可以当D1和D2域进入Dstandby待机方式后，继续保存用户数据。 Backup SRAM：位于D3域，数据带宽是32bit，挂在AHB总线上。主要用于系统进入低功 ​ 耗模式后，继续保存数据（Vbat引脚外接电池）。 四、Block 2 地址范围 功能 0x4000 0000 ~ 0x4000 D3FF APB1总线外设 0x4000 D400 ~ 0x4000 FFFF 保留 0x4001 0000 ~ 0x4001 77FF APB1总线外设 0x4001 7800 ~ 0x4001 FFFF 保留 0x4002 0000 ~ 0x400B FFFF APB1总线外设 0x400C 0000 ~ 0x4801 FFFF 保留 0x4802 0000 ~ 0x4802 2BFF APB1总线外设 0x4802 2C00 ~ 0x4FFF FFFF 保留 0x5000 0000 ~ 0x5000 3FFF APB1总线外设 0x5000 4000 ~ 0x50FF FFFF 保留 0x5100 0000 ~ 0x5200 8FFF APB1总线外设 0x5200 9000 ~ 0x57FF FFFF 保留 0x5800 0000 ~ 0x5800 6BFF APB1总线外设 0x5800 6C00 ~ 0x5801 FFFF 保留 0x5802 0000 ~ 0x5802 67FF APB1总线外设 0x5802 6800 ~ 0x5FFF FFFF 保留","tags":["启动过程"],"categories":["MCU开发"]},{"title":"STM32之sct分散加载描述文件","path":"/MCU开发/STM32分散加载描述文件/","content":"在 STM32嵌入式开发 中，分散加载文件（.sct或.ld文件）是ARM编译器用来定义代码和数据在存储空间的布局的链接脚本。它告诉编译器如何将代码和数据分配到不同的存储区域（如Flash、RAM、TCM等）。合理使用分散加载文件可以优化性能、提高实时性，甚至增强系统稳定性。 STM32的sct分散加载描述文件如下： ; *************************************************************; *** Scatter-Loading Description File generated by uVision ***; *************************************************************LR_IROM1 0x08000000 0x00020000 ; load region size_region\tER_IROM1 0x08000000 0x00020000 ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) .ANY (+XO) RW_IRAM1 0x20000000 0x00020000 ; RW data .ANY (+RW +ZI) 对上述分散加载文件逐行解析如下：一、定义加载区域（Load Region）LR_IROM1 0x08000000 0x00020000 ; load region size_region LR_IROM1：加载区域名称（自定义）。 0x08000000：加载区域起始地址（STM32 程序运行 起始地址，可以重映射）。 0x00020000：区域大小（128KB， 加载区容量）。 作用：定义 Flash 或其他内存的存储范围，代码和常量在此区域存放。 2）定义执行区域（Execution Region）ER_IROM1 0x08000000 0x00020000 ; load address = execution address ER_IROM1：执行区域名称（与加载区域名称可以不同）。 0x08000000：执行地址（与加载地址相同，表示代码在 Flash 中原地执行）。 0x00020000：区域大小（需 ≤ 加载区域大小）。 作用：代码实际运行时仍位于 Flash 中。 （3）指定复位向量和启动代码*.o (RESET, +First) *.o (RESET, +First) *.o：匹配所有目标文件。 (RESET)：选择所有名为 RESET 的段（通常包含中断向量表）。 +First：强制将该段放在该区域的起始地址。 作用：确保中断向量表位于 0x08000000（STM32 上电将从此处加载SP和PC指针）。 （4）C 库初始化段*(InRoot$$Sections) InRoot$$Sections：ARM 编译器的内置命名，包含 C 库初始化所需的代码和数据（如 __main 的堆栈初始化代码）。 作用：处理 C 运行时环境的初始化。 （5）所有只读代码和常量.ANY (+RO) .ANY：匹配所有未被分配的目标文件。 +RO：选择只读（Read-Only）段（包括代码 .text 和常量 .constdata）。 作用：将程序代码和常量放入 Flash。 （6）所有可执行的只读代码.ANY (+XO) +XO：选择可执行（eXecute Only）段（某些安全芯片需要代码加密后执行）。 注意：STM32 通常不使用此属性，代码默认可读可执行（+RO 已包含）。 （7）定义 RAM 区域RW_IRAM1 0x20000000 0x00020000 ; RW data RW_IRAM1：RAM 执行区域名称。 0x20000000：STM32 内置 RAM 起始地址。 0x00020000：区域大小（128KB，取决于具体型号）。 作用：定义读写变量的存储位置。 （8）分配读写数据和零初始化数据.ANY (+RW +ZI) +RW：选择已初始化的读写数据（如全局变量 int a = 5;）。 +ZI：选择零初始化数据（如全局变量 int b;）。 关键流程： 上电时，+RW 数据从 Flash 拷贝到 RAM。 +ZI 数据由启动代码在 RAM 中清零。 欢迎关注本人微信公众号：","tags":["STM32"],"categories":["MCU开发"]},{"title":"Vscode编辑stm32工程配置","path":"/环境配置/Vscode编辑stm32工程配置/","content":"在工程下创建.vscode文件夹 c_cpp_properties.json文件 configurations: [ name: Win32, includePath: [ $workspaceFolder/**, ./Core/Inc, ./Drivers/STM32h7xx_HAL_Driver/Inc, ./Drivers/STM32h7xx_HAL_Driver/Inc/Legacy, ./Drivers/CMSIS/Device/ST/STM32h7xx/Include, ./Drivers/CMSIS/Include, ./Middlewares/Lwip/src/include, ./Middlewares/LwIP/arch, ./Middlewares/Lwip/src/include/lwip, ./Middlewares/Lwip/src/include/netif, ./Middlewares/Lwip/src/core/ipv4, // ./Middlewares/Third_Party/RealThread_RTOS_RT-Thread/include/, // ./Middlewares/Third_Party/RealThread_RTOS_RT-Thread/include/libc/include/, // ./Middlewares/Third_Party/RealThread_RTOS_RT-Thread/include/libc/extension/, // ./Middlewares/Third_Party/RealThread_RTOS_RT-Thread/include/libc/extension/fcntl/msvc/, // ./Middlewares/Third_Party/RealThread_RTOS_RT-Thread/include/libc/extension/fcntl/octal/, ./HYZY/BSP/Inc, ./HYZY/Function/Inc ], defines: [ _DEBUG, UNICODE, _UNICODE, __CC_ARM, USE_HAL_DRIVER, STM32H743xx ], windowsSdkVersion: 10.0.19041.0, compilerPath: cl.exe, cStandard: c17, cppStandard: c++17, intelliSenseMode: msvc-arm64 ], version: 4 settings.json文件 files.associations: filter.h: c, data_handle.h: c, bsp_lan8720.h: c, memorymap.h: c, eth.h: c, ethernetif.h: c, stm32h7xx_hal_eth.h: c, sys.h: c, etharp.h: c, string.h: c, bsp_w25q.h: c, pbuf.h: c","tags":["vscode"],"categories":["环境配置"]},{"title":"常用存储器介绍","path":"/嵌入式基础/常用存储器介绍/","content":"存储器是计算机系统中不可或缺的重要组成部分。它主要用于存储程序代码和数据，使计算机具备记忆和运行的功能。 存储器按其存储介质特性主要分为两大类：易失性存储器和非易失性存储器。 易失性存储器：在断电后数据会丢失，如 RAM。 非易失性存储器：即使断电也能保留数据，如 ROM、Flash，以及一些新兴技术。 一、易失性存储器（RAM）RAM（Random Access Memory）是易失性的半导体存储器，用于存储运行中的程序和数据。 1、动态随机存储器DRAM（Dynamic RAM）动态随机存储器（DRAM） 是一种易失性存储器，采用电容存储数据（电容带电表示 1，不带电表示 0），需要定期刷新以维持数据完整性。由于其依赖时钟信号进行数据传输，因此通常被称为同步 DRAM（SDRAM），并常采用SDR（Single Data Rate）或DDR（Double Data Rate）模式。 2、静态随机存储器SRAMSRAM 的存储单元通过锁存器保存数据，不需要刷新。它的访问速度比 DRAM 快，但存储密度较低，成本较高。通常用于 CPU 的高速缓存 或 内部数据存储。 两者对比如下表： 特性 DRAM SRAM 存取速度 较慢 较快 集成度 较高 较低 生产成本 较低 较高 是否需要刷新 是 否 应用 用于CPU内部的高速缓存(Cache) 外部存储 二、非易失性存储器（ROM）ROM（Read Only Memory）是一种非易失性的半导体存储器，决定了存储的数据不会因为断电而丢失。尽管早期的 ROM 不能写入，但随着技术发展，现在一般包括多种可编程类型，如 EEPROM 和 Flash。 MASK ROM：出厂时通过工艺固化的数据，不可修改。 OTPROM（One-Time Programmable ROM）：一次性可编程，不可更改。 EPROM：需要紫外线擦除后可重新写入。 EEPROM：支持电擦除，可以重复擦写，适用于需要动态更新数据的场景。 特性 MASK ROM OTPRPM EPROM EEPROM 数据可写性 ❌ 不可写 ❌ 不可写 ✅ 可擦写 ✅ 可擦写 读写速度 ✅ 快 ✅ 快 ✅ 慢 ✅ 慢 集成度 ✅ 较低 ✅ 较低 ✅ 较低 ✅ 较低 用途 固件存储（旧设备） 固件存储（一次性） 固件存储（可编程） 固件存储（可更新） 三、非易失性存储器（FLASH）FLASH 存储器，又称为 Flash ROM，是一种可擦写的非易失性存储器，广泛应用于嵌入式系统、消费电子产品和数据中心。根据其结构和访问方式，FLASH 主要分为 NOR Flash 和 NAND Flash 两种。 特性 NOR FLASH NAND FLASH 同容量存储器成本 较贵 较便宜 集成度 较低 较高 介质类型 随机存储 连续存储 地址线和数据线 独立分开 共用 擦除单元 以“扇区块”擦除 以“扇区块”擦除 读写单元 可以基于字节读写 必须以“块”为单位读写 读取速度 较高 较低 写入速度 较低 较高 坏块 较少 较多 是否支持XIP 支持 不支持 四、应用在嵌入式系统中，通常使用 Flash 存储程序 + RAM 运行程序，ROM 已逐渐被 Flash 替代，但在一些低成本设备中，仍用于固定存储场景（如早期 MCU 的 Boot ROM）。 特性 RAM ROM Flash 读写速度 最快 较慢 读取快、写入慢 掉电数据 丢失 保留 保留 用途 运行程序 固件存储（旧设备） 程序+数据存储 擦写次数 不限 一次有限 有限（10万次+） 五、新兴存储器技随着信息技术的快速发展，存储技术也在不断创新与演进。除了传统的 RAM、ROM 和 Flash 存储器，近年来涌现出一系列新兴的非易失性存储器技术，如 MRAM、ReRAM、FRAM 和 3D XPoint 等。这些技术在数据保留能力、读写速度、功耗、耐久性等方面具有显著优势，正在逐步改变存储器的格局，成为未来智能系统、物联网设备、边缘计算和高性能计算领域的重要组成部分。 存储器类型 原理 非易失性 读写速度 耐久性 适用场景 MRAM 基于磁性隧道结（MTJ），磁性材料的电阻状态变化 ✅ 是 高 数十亿次 IoT设备、控制系统、缓存 ReRAM 基于材料的电阻变化（如氧化物的电阻变化） ✅ 是 中 数百万到数亿次 AI芯片、物联网设备 FRAM 基于铁电晶体的极化状态 ✅ 是 非常快 数百万次以上 数据记录、传感器数据存储 3D XPoint 结合了DRAM和Flash的优点，支持逐字节访问 ✅ 是 高 非常高 数据库、大数据存储 FPGA Block RAM 基于SRAM，可掉电保存（支持电池备份） ✅ 可选 高 无限次 FPGA内部数据暂存 FPGA Distributed RAM 基于逻辑单元实现的SRAM ❌ 否 高 无限次 配置寄存器、状态数据 六、其他1、为什么叫 NOR NAND？在 Flash 存储技术中： NOR Flash 的存储单元结构采用了类似于 NOR 逻辑门 的电路设计，支持随机访问，能够如 RAM 一样寻址单个字节。 NAND Flash 的存储单元结构采用类似于 NAND 逻辑门 的串联设计，访问方式为 块页，不适合直接执行代码，但适合大数据量存储。 2、什么是DDR模式和SDR模式？DDR（Double Data Rate） 和 SDR（Single Data Rate） 是两种常用的内存数据传输模式，其主要区别在于对时钟信号的使用： SDR (Single Data Rate)：数据仅在时钟的上升沿被采样，一个时钟周期传输一次数据； DDR (Double Data Rate)：数据在时钟的上升沿和下降沿分别被采样，一个时钟周期可以传输两次数据，因此传输速率更高。","tags":["basic"],"categories":["嵌入式基础"]},{"title":"ubuntu config","path":"/Linux/ubuntu配置/","content":"一、更新下载镜像源修改目标文件： /etc/apt/sources.list 地址替换为下述地址： 阿里源 mirrors.aliyun.com 清华源 mirrors.tuna.tsinghua.edu.cn 更新本地安装包数据库： sudo apt update","tags":["config"],"categories":["Linux"]},{"title":"typedef用法","path":"/再探C语言/typedef用法/","content":"良好的代码习惯和高效的类型定义在项目中扮演着至关重要的角色。typedef，它不仅是一个语法糖，更是提升代码质量和可维护性的利器。在这篇文章中，将为你介绍typedef 4 种应用方式。 应用一、为基本数据类型定义新的类型名用uint32_t替代unsigned int声明变量 /* 变量名重定义 */typedef unsigned int uint32_t;/* 定义一个`unsigned int`类型的变量 */uint32_t count = 0; 应用二、为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称使用结构体定义以及声明结构体变量： struct TagPoint double x; double y; double z;;/* 定义一个三维坐标结构体 *//* 声明一个三维坐标点 */struct TagPoint point = 0, 0, 0; 使用typedef代替结构体定义以及声明结构体变量： typedef struct double x; double y; double z; TagPoint;/* 定义一个三维坐标结构体 *//* 声明一个三维坐标点 */TagPoint point = 0, 0, 0; 应用三、定义数组类型定义多个同纬度的数组： int v[3];int i[3]; 使用typedef重定义： /* 定义数组类型 */typedef int arry_int_3[3];/* 等价于 int v[3] */arry_int_3 v; 应用四、定义指针类型1、定义数组指针类型/* 普通数组指针 */int (*arr_p)[5];//定义了一个数组指针变量arr_p，arr_p可以指向一个int a[5]的一维数组/* 使用typedef */typedef int(*Arr_P)[5];//定义一个指针类型，该类型的指针可以指向含5个int元素的一维数组int a[5] = 1,2,3,4,5;Arr_P p;//定义数组指针变量pp= a;//完全合法，无警告 p= (Arr_P)a;//类型强制转换为Arr_P，完全合法，无警告 2、定义函数指针类型有一个函数原型如下： /* 函数原型 */int32_t write_adc_reg(uint32_t reg_addr, uint32_t data, uint32_t chip_id);int32_t write_spi_reg(uint32_t reg_addr, uint32_t data, uint32_t chip_id); 普通定义一个函数指针指向这个函数： /* 普通函数指针定义和使用 */int32_t (*write_adc_reg_p)(uint32_t, uint32_t, uint32_t);int32_t (*write_spi_reg_p)(uint32_t, uint32_t, uint32_t);/* 选择不同的写入接口 */write_adc_reg_p = write_adc_reg;write_spi_reg_p = write_spi_reg;/* 调用 */int32_t result = write_reg_p(0x10, 0x55, 0); 使用typedef： /* 定义函数指针类型 */typedef int32_t (*WriteReg_P)(uint32_t, uint32_t, uint32_t);/* 声明两个函数指针变量 */WriteReg_P write_adc_reg_p = write_adc_reg;WriteReg_P write_spi_reg_p = write_spi_reg;/* 调用 */int32_t adc_val = write_adc_reg_p(0x10, 0x55, 0); 五、总结typedef 是 C 语言中非常实用的工具，它不仅能提升代码的可读性，还便于后续维护和扩展。在嵌入式开发中，通过合理使用 typedef，我们可以简化结构体、指针、函数指针等复杂类型的声明，让代码更清晰、表达更简洁。","tags":["typedef"],"categories":["再探C语言"]},{"title":"MPU内存保护单元","path":"/MCU开发/MPU内存保护单元/","content":"MPU，即内存保护单元，可以设置不同存储区域的存储器访问特性（用户级、特权访问、全访问）和存储器属性（如可缓存、可缓冲、可共享），对存储器（主要是内存和外设）提供保护，从而提高系统可靠性。 存储器访问特性 权限类型 特权模式（内核） 用户任务 典型用途 特权只读（PRIV_RO） 可读 不可访问 (触发故障) 保护只读内核代码常量 特权读写（PRIV_RW） 可读写 不可访问 (触发故障) 内核数据结构、关键寄存器 全访问(FULL_ACCESS) 可读写 可读写 用户堆栈、共享内存 存储器属性 存储器属性 硬件行为 数据一致性 典型用途 可缓存 读写经过Cache 需软件维护（CleanInvalidate） 单核私有高性能数据 可缓冲 写入通过Write Buffer异步完成 可能导致顺序重排 低速外设寄存器 可共享 允许多主设备访问 硬件强制同步或禁用缓存 DMA缓冲区、多核共享内存 作用 阻止用户应用程序破坏操作系统使用的数据； 阻止一个任务访问其他任务的数据区，从而隔离任务； 把关键数据区域设置为只读从根本上解决被破切的可能； 检测意外的存储访问，如堆栈溢出、数组越界等； 将SRAM或RAM空间定义为不可执行，防止注入攻击； STM32的MPU保护单元配置在STM32H743（Cortex-M7内核）中，MPU可配置保护16个内存保护区域，每个区域最小要求256字节，且每一个区域还可配置为8个子域（大小一样）。 一、MPU控制模式MPU（Memory Protection Unit）控制模式决定了在默认状态或异常处理期间MPU的行为及其对内存访问的影响。 控制模式 背景区域行为 异常期间MPU状态 安全性 典型用途 NOT USED 无，所有内存开放 无效 无 调试无保护需求 BR禁访+MPU异常禁用 不可访问 禁用 中 通用RTOS BR禁访+MPU异常启用 不可访问 启用 高 高安全固件 BR特权+MPU异常禁用 仅特权访问 禁用 中-高 特权分离系统（如Linux内核空间） BR特权+MPU异常启用 仅特权访问 启用 最高 安全认证产品（ISO 26262 ASIL-D） 二、三种内存类型 Normal memory：CPU以最高效的方式加载和存储字节、半字和字，CPU对于这种内存区的加载或存储不一定要按照程序代码的顺序执行； Device memory：加载和存储要严格按照次序进行，硕确保寄存器按照正确顺序执行； Strongly ordered memory：程序完全按照代码顺序执行，CPU会等待当前加载存储执行完毕后才执行下一条指令，导致性能下降。 内存类型 适用对象 性能 Normal memory ROM、FLASH、SRAM 高 Device memory 外设 中 Strongly ordered memory 强序 低 三、Cache介绍Cache(高级缓存)是提升STM32性能的关键一步。M7内核芯片做了一级Cache支持，Cache分为数据缓存D-Cache和指令缓存I-Cache。 Cache支持4种基本操作：(使能、清空、禁止、无效化）。 数据缓存D-Cache是解决CPU加速访问SRAM，MPU能够指定区域的Cache策略 1、Cache写操作 写命中（Cache hit）：CPU要写的SRAM区数据在Cache中已经开辟了对应的区域； 处理方式 说明 write through 直接写到内存并并同时放到cache里面，内存和cache同步更新 write back 数据更新时只写入cache，只有数据替换时被修改的cache数据才写到内存 写不命中（Cache Miss）：Cache里面没有开辟对应的区域； 处理方式 说明 write allocate 把要写的数据载入到cache，对cache写后更新到内存 no write allocate 直接写入内存 2、Cache读操作 读命中（Cache hit）：CPU要读取的SRAM区数据在Cache中已经加载好； 处理方式 说明 Cache read 直接从cache中读出数据即可（不能保证数据一致性） 读不命中（Cache Miss）：Cache里面没有需要读的数据； 处理方式 说明 read through 直接从内存中读出，不用cache read allocate 把数据从内存加载到cache，再从cache读取 2、数据一致性解决 设置共享属性 Cache相当于没有开启。 软件维护 操作 函数 说明 clean清空 SCB_CleanDCache() 当Cache已变化，内存没有更新时，DMA搬运之前进行此操作，将Cache同步到内存 invalidata无效化 SCB_InvalidataDCache() 当SRAM数据已变化，Cache未更新时,DMA搬运数据后，将SRAM数据同步到Cache中 二、区域设置 配置项 说明 MPU Region 参数类型：EnableDisable，是否启用区域MPU区域保护 MPU Region Base Address 定义Region 0的起始地址（地址必须按区域大小对齐） MPU Region Size 设置Region 0覆盖的内存大小。 MPU TEX field level 扩展内存类型（用于细化内存属性和缓存策略） MPU Shareability Permission 参数类型：EnableDisable，是否共享 MPU Cacheable Permissionn 参数类型：EnableDisable，是否缓存 MPU Bufferable Permissionn 参数类型：EnableDisable，是否缓冲 MPU Instruction Access 参数类型：EnableDisable，是否使能从该区域执行指令。 MPU Access Permission 见下表 TEX是内存的“身份证”，告诉硬件它属于哪一类（普通RAM、设备寄存器还是特殊内存），而CB是它的“行为指南”（如何读写）。两者协作但职责分离。 MPU设置内存的访问权限（MPU Access Permission） 参数 执行（x） 读（R） 写（W） 典型用途 ALL ACCESS NOT PERMITTED ❌ ❌ ❌ 内存隔离非法访问检测 Privileged READS ❌ ✔️ ❌ 只读配置表（仅内核可访问） Privileged READS + Unprivileged READS ❌ ✔️ ❌ 全局只读数据 Privileged READ/WRITE ❌ ✔️ ✔️ 内核数据结构 外设寄存器 Privileged READ/WRITE + Unprivileged READS ❌ ✔️ ❌ 安全日志（用户只读，内核可写） ALL ACCESS PERMITTED ✔️ ✔️ ✔️ 完全开放区域（调试启动阶段） 三、建议配（MPU_TEX_LEVEL0）（注意考虑数据一致性问题） 设备 基地址 区域大小 指令访问 访问权限 共享、Cache、缓冲 DTCM 0x2000 0000 128K 允许 全访问 不共享、cache、缓冲 AXI SRAM 0x2400 0000 512K 允许 全访问 不共享、cache、缓冲 SRAM1~3 0x3000 0000 512K 允许 全访问 不共享、cache、缓冲 SRAM4 0x3800 0000 64K 允许 全访问 不共享、cache、缓冲 FMC 0x6000 0000 64M 允许 全访问 不共享、不cache、不缓冲 SDRAM OxC000 0000 64M 允许 全访问 不共享、cache、缓冲 NAND 0x8000 0000 256M 不允许 全访问 不共享、不cache、不缓冲 SPI FLASH 0x9000 0000 8M 允许 全访问 不共享、cache、缓冲","tags":["MPU内存保护"],"categories":["MCU开发"]},{"title":"Git使用","path":"/工具使用/Git使用/","content":"一、Git配置： 打开Git Bash依次输入以下命令配置个人信息： git config --global user.name 名称git config --global user.email 邮箱地址git config --global user.password 密码 输入以下命令可以查看个人配置信息 git config --global --list 在User下找到.ssh文件夹生成id_rsa.pub文件作为SSH密钥 ssh-keygen -t rsa 配置配置.gitignore文件以此来忽略不需要提交的git文件 ######################################################################################### gitIgnore For Keil###################################################################################### Prerequisites*.d# Compiled Object files*.slo*.lo*.o*.obj# Precompiled Headers*.gch*.pch# Compiled Dynamic libraries*.so*.dylib*.dll# Fortran module files*.mod*.smod# Compiled Static libraries*.lai*.la*.a*.lib*.ia# Executables*.exe*.out*.app# vscode.vscode# KeilDebugConfigRTE*.lst*.uvguix.*RTE_Components.h/private/# Compile File*.lst*.htm*.sct*.crf*.map*.hex*.lnp*.axf*.dep*.iex*.__i*.Bak*.scvd*.html 二、Git基础使用 初始化仓库 git init 将文件添加到暂存区 git add . 提交到本地 git commit -m 提交描述 连接到远程仓库（不是必须的） git remote add origin xxxxxx为远程仓库地址，你可自行在gitee上创建仓库 提交到远程仓库 #完整写法git push -u origin 远程分支:本地分支#远程分支与本地分支同名git push -u origin 远程分支 从远程获取代码并合并本地的版本 #更新操作git pull#将远程主机 origin 的 master 分支拉取过来，与本地的 master 分支合并。git pull origin master:master 二、辅助命令 查看当前文件状态 git status 查看提交日志 git log 为最新一次提交打上标签，一般用于发布版本 git tag tagname 三、分支操作 创建分支（会继承当前分支状态） #创建分支git branch branchname#创建分支并切换git checkout -b branchname 切换分支 git checkout branchname 查看分支 #查看本地分支git branch#查看远程分支git branch -a 将某分支合并到当前分支 git merge branchname 删除分支 #删除本地分支git branch -d branchname#强制删除未合并的分支git branch -D branchname#删除远程分支git push origin --delete branchname 如果git merge的时候出现冲突，可以执行下面的命令取消merge git merge --abort","tags":["版本管理"],"categories":["工具使用"]},{"title":"PM2进程管理工具","path":"/工具使用/PM2进程管理工具/","content":"一、安装PM2 nvm是官方安装nodejs的工具，安装方式如下： # 安装 nvm (Node 版本管理器)curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash# 如果上面进度慢，可以尝试国内镜像版本curl -o- https://gitee.com/mirrors/nvm/raw/v0.40.0/install.sh | bash 更改Node.js 下载镜像源（如淘宝镜像）： # 临时生效export NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node# 永久生效（写入Shell配置文件）echo export NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node ~/.bashrcsource ~/.bashrc 下载nodejs # 下载并安装 Node.js（可能需要重启终端）# 第一次安装之后可能没有 nvm 命令，退出终端，再进一遍就好了nvm install 22# 验证环境中是否存在正确的 Node.js 版本node -v # 应该打印 `v22.12.0`# 验证环境中是否存在正确的 npm 版本npm -v # 应该打印 `10.9.0` 安装PM2 npm install pm2 -g 二、PM2的使用 查看PM2版本 pm2 -v 编写pm2的js脚本，这里编写（hexo启动版本，hexo_run.js） //runconst exec = require(child_process)exec(hexo server,(error, stdout, stderr) = if(error) console.log(exec error: $error) return console.log(stdout: $stdout); console.log(stderr: $stderr);) 启动进程服务 #简单启动进程pm2 start hexo_run.js#启动进程，命名为为hexo_runpm2 start app.js --name hexo_run 结束进程 #结束某个进程pm2 stop ID/名字#停止所有进程pm2 stop all#重新启动所有进程pm2 restart all#重新加载一个由 PM2 管理的应用程序。重新启动应用进程，不会中断服务。pm2 reload hexo_run.js 查看所有进程状态 pm2 list 日志管理 #查看所有进程状态pm2 logs#查看某个进程状态pm2 logs ID/名字 删除应用 #删除某个进程pm2 delete ID/名字#删除所有进程pm2 delete all","tags":["Linux"],"categories":["工具使用"]},{"title":"FreeRTOS","path":"/MCU开发/FreeRTOS学习/","content":"1、动态创建任务#include main.h#include driver_led.h#include driver_key.hvoid FreeRTOS_Start(void);int main(void) // 初始化HAL库函数必须要调用此函数 HAL_Init(); // 系统时钟即AHB/APB时钟配置 SystemClock_Config(); // 初始化LED LedGpioInit(); KeyInit(); FreeRTOS_Start();TaskHandle_t start_task_handle;TaskHandle_t task1_handle;TaskHandle_t task2_handle;TaskHandle_t task3_handle;void StartTask(void);void Task1(void);void Task2(void);void Task3(void);void FreeRTOS_Start(void) xTaskCreate( (TaskFunction_t) StartTask, //任务函数的地址 (char *) StartTask, //任务函数的名称 (uint16_t) 128, //任务函数栈空间大小 (void *) NULL, //任务函数的参数 (UBaseType_t) 1, //任务函数的优先级 (TaskHandle_t*) start_task_handle //任务函数的句柄 ); //启动调度器 vTaskStartScheduler();void StartTask(void) taskENTER_CRITICAL(); xTaskCreate( (TaskFunction_t) Task1, (char *) Task1, (uint16_t) 128, (void *) NULL, (UBaseType_t) 2, (TaskHandle_t*) task1_handle ); xTaskCreate( (TaskFunction_t) Task2, (char *) Task2, (uint16_t) 128, (void *) NULL, (UBaseType_t) 3, (TaskHandle_t*) task2_handle ); xTaskCreate( (TaskFunction_t) Task3, (char *) Task3, (uint16_t) 128, (void *) NULL, (UBaseType_t) 4, (TaskHandle_t*) task3_handle ); vTaskDelete(NULL); taskEXIT_CRITICAL();void Task1(void) while(1) LED_TOGGLE(LED0_GPIO_PORT,LED0_GPIO_PIN); vTaskDelay(500); void Task2(void) while(1) LED_TOGGLE(LED1_GPIO_PORT,LED1_GPIO_PIN); vTaskDelay(500); void Task3(void) while(1) if(KeyScan() == 0) if(task1_handle != NULL) vTaskDelete(task1_handle); task1_handle = NULL; vTaskDelay(500); 2、静态创建任务#include main.h#include driver_led.h#include driver_key.h/* 启动任务的配置 */#define START_TASK_STACK 128#define START_TASK_PRIORITY 1TaskHandle_t start_task_handle;StackType_t start_task_stack[START_TASK_STACK]; // 静态任务的任务栈，以数组形式存储StaticTask_t start_task_tcb; // 静态任务的TCB结构体类型void start_task(void);/* 任务1的配置 */#define TASK1_STACK 128#define TASK1_PRIORITY 2TaskHandle_t task1_handle;StackType_t task1_stack[TASK1_STACK]; // 静态任务的任务栈，以数组形式存储StaticTask_t task1_tcb; // 静态任务的TCB结构体类型void task1(void);/* 任务2的配置 */#define TASK2_STACK 128#define TASK2_PRIORITY 3TaskHandle_t task2_handle;StackType_t task2_stack[TASK2_STACK]; // 静态任务的任务栈，以数组形式存储StaticTask_t task2_tcb; // 静态任务的TCB结构体类型void task2(void);/* 任务3的配置 */#define TASK3_STACK 128#define TASK3_PRIORITY 4TaskHandle_t task3_handle;StackType_t task3_stack[TASK3_STACK]; // 静态任务的任务栈，以数组形式存储StaticTask_t task3_tcb; // 静态任务的TCB结构体类型void task3(void);/* ======================= 静态创建方式，需要手动指定2个特殊任务的资源=============================== *//* 空闲任务的配置 */StackType_t idle_task_stack[configMINIMAL_STACK_SIZE]; // 静态任务的任务栈，以数组形式存储StaticTask_t idle_task_tcb; // 静态任务的TCB结构体类型/* 软件定时器任务的配置 */StackType_t timer_task_stack[configTIMER_TASK_STACK_DEPTH]; // 静态任务的任务栈，以数组形式存储StaticTask_t timer_task_tcb; // 静态任务的TCB结构体类型/* 分配空闲任务的资源 */void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) *ppxIdleTaskTCBBuffer = idle_task_tcb; *ppxIdleTaskStackBuffer = idle_task_stack; *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;/* 分配软件定时器任务的资源 */void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) *ppxTimerTaskTCBBuffer = timer_task_tcb; *ppxTimerTaskStackBuffer = timer_task_stack; *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;/** * @description: 启动FreeRTOS * @return * */void FreeRTOS_Start(void) /* 1.创建一个启动任务 */ start_task_handle = xTaskCreateStatic( (TaskFunction_t)start_task, // 任务函数的地址 (char *)start_task, // 任务名字符串 (uint32_t)START_TASK_STACK, // 任务栈大小，默认最小128，单位4字节 (void *)NULL, // 传递给任务的参数 (UBaseType_t)START_TASK_PRIORITY, // 任务的优先级 (StackType_t *)start_task_stack, // 我们创建的任务栈（数组存储）的地址 (StaticTask_t *)start_task_tcb // 我们创建的tcb的地址 ); /* 2.启动调度器:会自动创建空闲任务和软件定时器（如果开启）， 静态创建的方式需要去实现2个分配资源的接口函数 */ vTaskStartScheduler();int main(void) // 初始化HAL库函数必须要调用此函数 HAL_Init(); // 系统时钟即AHB/APB时钟配置 SystemClock_Config(); // 初始化LED LedGpioInit(); KeyInit(); FreeRTOS_Start();/** * @description: 启动任务：用来创建其他Task * @param void *pvParameters * @return * */void start_task(void) /* 进入临界区:保护临界区里的代码不会被打断 */ taskENTER_CRITICAL(); /* 使用静态创建3个任务 */ task1_handle = xTaskCreateStatic( (TaskFunction_t)task1, (char *)task1, (configSTACK_DEPTH_TYPE)TASK1_STACK, (void *)NULL, (UBaseType_t)TASK1_PRIORITY, (StackType_t *)task1_stack, // 我们创建的任务栈（数组存储）的地址 (StaticTask_t *)task1_tcb // 我们创建的tcb的地址 ); task2_handle = xTaskCreateStatic( (TaskFunction_t)task2, (char *)task2, (configSTACK_DEPTH_TYPE)TASK2_STACK, (void *)NULL, (UBaseType_t)TASK2_PRIORITY, (StackType_t *)task2_stack, // 我们创建的任务栈（数组存储）的地址 (StaticTask_t *)task2_tcb // 我们创建的tcb的地址 ); task3_handle = xTaskCreateStatic( (TaskFunction_t)task3, (char *)task3, (configSTACK_DEPTH_TYPE)TASK3_STACK, (void *)NULL, (UBaseType_t)TASK3_PRIORITY, (StackType_t *)task3_stack, // 我们创建的任务栈（数组存储）的地址 (StaticTask_t *)task3_tcb // 我们创建的tcb的地址 ); /* 启动任务只需要执行一次即可，用完就删除自己 */ vTaskDelete(NULL); /* 退出临界区 */ taskEXIT_CRITICAL();void task1(void) while(1) LED_TOGGLE(LED0_GPIO_PORT,LED0_GPIO_PIN); vTaskDelay(500); void task2(void) while(1) LED_TOGGLE(LED1_GPIO_PORT,LED1_GPIO_PIN); vTaskDelay(500); void task3(void) while(1) if(KeyScan() == 0) if(task1_handle != NULL) vTaskDelete(task1_handle); task1_handle = NULL; vTaskDelay(500); 3、任务挂起与回复3.1、任务挂起/*传入参数为任务句柄，若传入NULL，则代表挂起当前任务*/vTaskSuspend(task1_handle); 3.2 任务恢复/* 任务恢复，传入参数为任务句柄*/vTaskResume(task1_handle); 3.3 挂起任务调度器仅执行当前任务 vTaskSuspendAll(); 3.4 恢复任务调度器xTaskResumeAll(); 3.5 打印任务状态/* 传入参数为字符串 */vTaskList(str); 3.6 中断管理/*执行此函数后，在中断优先级阈值以下的中断将被屏蔽*/portDISABLE_INTERRUPTS();/* 使能中断 */portENABLE_INTERRUPTS(); 5、时间函数/* 相对延时，每隔n个时间片执行一次代码，不能保证代码执行时间相同 */vtaskDelay(n);/* 绝对延时，代码整体执行时间为n个时间片，保证代码执行周期*/xTaskDelayUntil(); 6、任务之间通过队列传输数据#include main.h#include driver_led.h#include driver_key.h#include driver_uart.hvoid StartTask(void);void Task1(void);void Task2(void);void FreeRTOS_Start(void);int main(void) // 初始化HAL库函数必须要调用此函数 HAL_Init(); // 系统时钟即AHB/APB时钟配置 SystemClock_Config(); // 初始化LED LedInit(); KeyInit(); UartInit(115200); FreeRTOS_Start(); while(1) HAL_Delay(1000); UartSendData(hello\\r ); LED_TOGGLE(LED0_GPIO_PORT,LED0_GPIO_PIN); /* 任务句柄，用以保存不同任务的配置 */TaskHandle_t start_task_handle;TaskHandle_t task1_handle;TaskHandle_t task2_handle;/* * 函数作用：常规写法，起始任务，用以创建其他任务 * 输入参数：无 * 返回值：无 * 作者：LSK*/void FreeRTOS_Start(void) xTaskCreate( (TaskFunction_t) StartTask, //任务函数的地址 (char *) StartTask, //任务函数的名称 (uint16_t) 128, //任务函数栈空间大小 (void *) NULL, //任务函数的参数 (UBaseType_t) 1, //任务函数的优先级 (TaskHandle_t*) start_task_handle //任务函数的句柄 ); /* 启用调度器，负责任务切换*/ vTaskStartScheduler();/* 队列句柄*/QueueHandle_t handle1;void StartTask(void) /* 创建一个队列 */ handle1 = xQueueCreate(1,sizeof(char *)); if(handle1 == NULL) UartSendData(task err); /* 进入临界保护区，保证在临界区的代码不会被打断*/ taskENTER_CRITICAL(); xTaskCreate( (TaskFunction_t) Task1, (char *) Task1, (uint16_t) 128, (void *) NULL, (UBaseType_t) 2, (TaskHandle_t*) task1_handle ); xTaskCreate( (TaskFunction_t) Task2, (char *) Task2, (uint16_t) 128, (void *) NULL, (UBaseType_t) 4, (TaskHandle_t*) task2_handle ); vTaskDelete(NULL); //删除任务本身 /* 退出临界保护区*/ taskEXIT_CRITICAL();/* * 函数作用：负责创建一个字符串，通过队列发送出去 * 输入参数：无 * 返回值：无 * 作者：LSK*/void Task1(void) char* str = tehsjncncncncc; while(1) if(KeyScan() == KEY0) /* 往队列插入一个值，并设置阻塞等待*/ xQueueSend(handle1,str,portMAX_DELAY); UartSendData(Send Pass\\r ); vTaskDelay(20); /* * 函数作用：接收数据任务 * 输入参数：无 * 返回值：无 * 作者：LSK*/void Task2(void) char *buffer; BaseType_t res; while(1) /* 接收队列的任务，并进入阻塞等待*/ res = xQueueReceive(handle1,buffer,portMAX_DELAY); if(res == pdPASS) UartSendData(buffer：\\r ); UartSendData(buffer); UartSendData(\\r ); vTaskDelay(500); 7、二进制信号量释放与接收7.1 二进制信号量#include main.hvoid StartTask(void);void Task1(void);void Task2(void);void FreeRTOS_Start(void);int main(void) // 初始化HAL库函数必须要调用此函数 HAL_Init(); // 系统时钟即AHB/APB时钟配置 SystemClock_Config(); // 初始化LED LedInit(); KeyInit(); UartInit(115200); FreeRTOS_Start(); while(1) HAL_Delay(1000); UartSendData(hello\\r ); LED_TOGGLE(LED0_GPIO_PORT,LED0_GPIO_PIN); /* 任务句柄，用以保存不同任务的配置 */TaskHandle_t start_task_handle;TaskHandle_t task1_handle;TaskHandle_t task2_handle;/* * 函数作用：常规写法，起始任务，用以创建其他任务 * 输入参数：无 * 返回值：无 * 作者：LSK*/void FreeRTOS_Start(void) xTaskCreate( (TaskFunction_t) StartTask, //任务函数的地址 (char *) StartTask, //任务函数的名称 (uint16_t) 128, //任务函数栈空间大小 (void *) NULL, //任务函数的参数 (UBaseType_t) 1, //任务函数的优先级 (TaskHandle_t*) start_task_handle //任务函数的句柄 ); /* 启用调度器，负责任务切换*/ vTaskStartScheduler();/* 队列句柄*/QueueHandle_t handle1;SemaphoreHandle_t semaphore_handle;void StartTask(void) /* 创建一个信号量 */ vSemaphoreCreateBinary(semaphore_handle); if(semaphore_handle != NULL) UartSendData(Create success!\\r ); /* 创建一个队列 */ handle1 = xQueueCreate(1,sizeof(char *)); if(handle1 == NULL) UartSendData(task err); /* 进入临界保护区，保证在临界区的代码不会被打断*/ taskENTER_CRITICAL(); xTaskCreate( (TaskFunction_t) Task1, (char *) Task1, (uint16_t) 128, (void *) NULL, (UBaseType_t) 2, (TaskHandle_t*) task1_handle ); xTaskCreate( (TaskFunction_t) Task2, (char *) Task2, (uint16_t) 128, (void *) NULL, (UBaseType_t) 4, (TaskHandle_t*) task2_handle ); vTaskDelete(NULL); //删除任务本身 /* 退出临界保护区*/ taskEXIT_CRITICAL();/* * 函数作用：释放信号量 * 输入参数：无 * 返回值：无 * 作者：LSK*/void Task1(void) BaseType_t res; while(1) if(KeyScan() == KEY0) /* 释放信号量 */ res = xSemaphoreGive(semaphore_handle); if (res == pdPASS) UartSendData(Send Pass\\r ); vTaskDelay(20); /* * 函数作用：接收信号量 * 输入参数：无 * 返回值：无 * 作者：LSK*/void Task2(void) BaseType_t res; while(1) /* 接收信号量是否释放 */ res = xSemaphoreTake(semaphore_handle, portMAX_DELAY); if(res == pdPASS) UartSendData(Take success!\\r ); UartSendData(\\r ); vTaskDelay(500); 7.2 互斥二进制信号量它会将阻塞高优先级的低优先级提升，从而保证高优先级不会被低优先级阻塞。 8、计数信号量释放与接收#include main.hvoid StartTask(void);void Task1(void);void Task2(void);void FreeRTOS_Start(void);int main(void) // 初始化HAL库函数必须要调用此函数 HAL_Init(); // 系统时钟即AHB/APB时钟配置 SystemClock_Config(); // 初始化LED LedInit(); KeyInit(); UartInit(115200); FreeRTOS_Start(); while(1) HAL_Delay(1000); UartSendData(hello\\r ); LED_TOGGLE(LED0_GPIO_PORT,LED0_GPIO_PIN); /* 任务句柄，用以保存不同任务的配置 */TaskHandle_t start_task_handle;TaskHandle_t task1_handle;TaskHandle_t task2_handle;/* * 函数作用：常规写法，起始任务，用以创建其他任务 * 输入参数：无 * 返回值：无 * 作者：LSK*/void FreeRTOS_Start(void) xTaskCreate( (TaskFunction_t) StartTask, //任务函数的地址 (char *) StartTask, //任务函数的名称 (uint16_t) 128, //任务函数栈空间大小 (void *) NULL, //任务函数的参数 (UBaseType_t) 1, //任务函数的优先级 (TaskHandle_t*) start_task_handle //任务函数的句柄 ); /* 启用调度器，负责任务切换*/ vTaskStartScheduler();char str[100];/* 队列句柄*/QueueHandle_t handle1;void StartTask(void) UBaseType_t Count = 0; /* 创建一个信号量 */ handle1 = xSemaphoreCreateCounting(100, 0); if(!(handle1 == NULL)) UartSendData(Create success!\\r ); Count = uxSemaphoreGetCount(handle1); sprintf(str, the init count: %d, Count); UartSendData(str); /* 进入临界保护区，保证在临界区的代码不会被打断*/ taskENTER_CRITICAL(); xTaskCreate( (TaskFunction_t) Task1, (char *) Task1, (uint16_t) 128, (void *) NULL, (UBaseType_t) 3, (TaskHandle_t*) task1_handle ); xTaskCreate( (TaskFunction_t) Task2, (char *) Task2, (uint16_t) 128, (void *) NULL, (UBaseType_t) 4, (TaskHandle_t*) task2_handle ); vTaskDelete(NULL); //删除任务本身 /* 退出临界保护区*/ taskEXIT_CRITICAL();/* * 函数作用：释放信号量 * 输入参数：无 * 返回值：无 * 作者：LSK*/void Task1(void) BaseType_t res; while(1) if(KeyScan() == KEY0) /* 释放信号量 */ res = xSemaphoreGive(handle1); if (res == pdPASS) UartSendData(Send Pass\\r ); vTaskDelay(20); /* * 函数作用：接收信号量 * 输入参数：无 * 返回值：无 * 作者：LSK*/void Task2(void) char str[100]; UBaseType_t Count = 0; BaseType_t res; while(1) /* 接收信号量是否释放 */ res = xSemaphoreTake(handle1, portMAX_DELAY); if(res == pdPASS) UartSendData(Take success!\\r ); UartSendData(\\r ); UartSendData(str); Count = uxSemaphoreGetCount(handle1); sprintf(str, the init count: %d\\r , Count); UartSendData(str); vTaskDelay(1000); 9、队列集10、事件标志组比信号量更灵活，每一个bit位都代表一个信号量。 #include main.hvoid StartTask(void);void Task1(void);void Task2(void);void FreeRTOS_Start(void);int main(void) // 初始化HAL库函数必须要调用此函数 HAL_Init(); // 系统时钟即AHB/APB时钟配置 SystemClock_Config(); // 初始化LED LedInit(); KeyInit(); UartInit(115200); FreeRTOS_Start(); while(1) HAL_Delay(1000); UartSendData(hello\\r ); LED_TOGGLE(LED0_GPIO_PORT,LED0_GPIO_PIN); /* 任务句柄，用以保存不同任务的配置 */TaskHandle_t start_task_handle;TaskHandle_t task1_handle;TaskHandle_t task2_handle;/* * 函数作用：常规写法，起始任务，用以创建其他任务 * 输入参数：无 * 返回值：无 * 作者：LSK*/void FreeRTOS_Start(void) xTaskCreate( (TaskFunction_t) StartTask, //任务函数的地址 (char *) StartTask, //任务函数的名称 (uint16_t) 128, //任务函数栈空间大小 (void *) NULL, //任务函数的参数 (UBaseType_t) 1, //任务函数的优先级 (TaskHandle_t*) start_task_handle //任务函数的句柄 ); /* 启用调度器，负责任务切换*/ vTaskStartScheduler();char str[100];EventGroupHandle_t event_handle;void StartTask(void) UBaseType_t Count = 0; /* 创建一个信号量 */ event_handle = xEventGroupCreate(); if(!(event_handle == NULL)) UartSendData(Create success!\\r ); /* 进入临界保护区，保证在临界区的代码不会被打断*/ taskENTER_CRITICAL(); xTaskCreate( (TaskFunction_t) Task1, (char *) Task1, (uint16_t) 128, (void *) NULL, (UBaseType_t) 3, (TaskHandle_t*) task1_handle ); xTaskCreate( (TaskFunction_t) Task2, (char *) Task2, (uint16_t) 128, (void *) NULL, (UBaseType_t) 4, (TaskHandle_t*) task2_handle ); vTaskDelete(NULL); //删除任务本身 /* 退出临界保护区*/ taskEXIT_CRITICAL();/* * 函数作用：发送事件 * 输入参数：无 * 返回值：无 * 作者：LSK*/#define EVENTBIT_0 (1 0)#define EVENTBIT_1 (1 1)void Task1(void) EventBits_t res; while(1) xEventGroupSetBits(event_handle, 13); if(KeyScan() == KEY0) /* 设置标志位*/ res = xEventGroupSetBits(event_handle, EVENTBIT_0); sprintf(str,event flag: %#x\\r , res); UartSendData(str); res = xEventGroupSetBits(event_handle, EVENTBIT_1); sprintf(str,event flag: %#x\\r , res); UartSendData(str); UartSendData(KEY0 PRESS!\\r ); vTaskDelay(20); /* * 函数作用：接收事件 * 输入参数：无 * 返回值：无 * 作者：LSK*/void Task2(void) EventBits_t res; while(1) /* 接收信号量是否释放 */ res = xEventGroupWaitBits( event_handle, // 事件句柄 ((EVENTBIT_0 | EVENTBIT_1)), // 等待的标志位 pdTRUE, // 是否清楚标志位 pdTRUE, // 是否等待标志位 portMAX_DELAY // 等待事件 ); sprintf(str, task2: %x\\r , res); UartSendData(str); 11 任务通知11.1 任务通知模拟信号量#include main.h#include portmacro.h#include projdefs.h#include stdint.hvoid StartTask(void);void Task1(void);void Task2(void);void FreeRTOS_Start(void);int main(void) // 初始化HAL库函数必须要调用此函数 HAL_Init(); // 系统时钟即AHB/APB时钟配置 SystemClock_Config(); // 初始化LED LedInit(); KeyInit(); UartInit(115200); FreeRTOS_Start(); while(1) HAL_Delay(1000); UartSendData(hello\\r ); LED_TOGGLE(LED0_GPIO_PORT,LED0_GPIO_PIN); /* 任务句柄，用以保存不同任务的配置 */TaskHandle_t start_task_handle;TaskHandle_t task1_handle;TaskHandle_t task2_handle;/* * 函数作用：常规写法，起始任务，用以创建其他任务 * 输入参数：无 * 返回值：无 * 作者：LSK*/void FreeRTOS_Start(void) xTaskCreate( (TaskFunction_t) StartTask, //任务函数的地址 (char *) StartTask, //任务函数的名称 (uint16_t) 128, //任务函数栈空间大小 (void *) NULL, //任务函数的参数 (UBaseType_t) 1, //任务函数的优先级 (TaskHandle_t*) start_task_handle //任务函数的句柄 ); /* 启用调度器，负责任务切换*/ vTaskStartScheduler();char str[100];void StartTask(void) /* 进入临界保护区，保证在临界区的代码不会被打断*/ taskENTER_CRITICAL(); xTaskCreate( (TaskFunction_t) Task1, (char *) Task1, (uint16_t) 128, (void *) NULL, (UBaseType_t) 3, (TaskHandle_t*) task1_handle ); xTaskCreate( (TaskFunction_t) Task2, (char *) Task2, (uint16_t) 128, (void *) NULL, (UBaseType_t) 4, (TaskHandle_t*) task2_handle ); vTaskDelete(NULL); //删除任务本身 /* 退出临界保护区*/ taskEXIT_CRITICAL();/* * 函数作用：任务通知发送 * 输入参数：无 * 返回值：无 * 作者：LSK*/void Task1(void) EventBits_t res; while(1) if(KeyScan() == KEY0) /* 实际使取出task2的通知值，然后＋1*/ xTaskNotifyGive(task2_handle); UartSendData(KEY0 PRESS!\\r ); vTaskDelay(200); /* * 函数作用：任务通知接收 * 输入参数：无 * 返回值：无 * 作者：LSK*/void Task2(void) uint32_t res_notify; while(1) res_notify = ulTaskNotifyTake( pdTRUE, //接收完通知后，是否对通知值处理，pdTRUE:置0；pdFALSE:-1 portMAX_DELAY //设置等待时间 ); sprintf(str, task2 notify: %d\\r , res_notify); UartSendData(str); 11.2 任务通知模拟消息队列（邮箱）#include main.h#include portmacro.h#include projdefs.h#include stdint.hvoid StartTask(void);void Task1(void);void Task2(void);void FreeRTOS_Start(void);int main(void) // 初始化HAL库函数必须要调用此函数 HAL_Init(); // 系统时钟即AHB/APB时钟配置 SystemClock_Config(); // 初始化LED LedInit(); KeyInit(); UartInit(115200); FreeRTOS_Start(); while(1) HAL_Delay(1000); UartSendData(hello\\r ); LED_TOGGLE(LED0_GPIO_PORT,LED0_GPIO_PIN); /* 任务句柄，用以保存不同任务的配置 */TaskHandle_t start_task_handle;TaskHandle_t task1_handle;TaskHandle_t task2_handle;/* * 函数作用：常规写法，起始任务，用以创建其他任务 * 输入参数：无 * 返回值：无 * 作者：LSK*/void FreeRTOS_Start(void) xTaskCreate( (TaskFunction_t) StartTask, //任务函数的地址 (char *) StartTask, //任务函数的名称 (uint16_t) 128, //任务函数栈空间大小 (void *) NULL, //任务函数的参数 (UBaseType_t) 1, //任务函数的优先级 (TaskHandle_t*) start_task_handle //任务函数的句柄 ); /* 启用调度器，负责任务切换*/ vTaskStartScheduler();char str[100];void StartTask(void) /* 进入临界保护区，保证在临界区的代码不会被打断*/ taskENTER_CRITICAL(); xTaskCreate( (TaskFunction_t) Task1, (char *) Task1, (uint16_t) 128, (void *) NULL, (UBaseType_t) 3, (TaskHandle_t*) task1_handle ); xTaskCreate( (TaskFunction_t) Task2, (char *) Task2, (uint16_t) 128, (void *) NULL, (UBaseType_t) 4, (TaskHandle_t*) task2_handle ); vTaskDelete(NULL); //删除任务本身 /* 退出临界保护区*/ taskEXIT_CRITICAL();/* * 函数作用：模拟消息队列发送 * 输入参数：无 * 返回值：无 * 作者：LSK*/void Task1(void) EventBits_t res; while(1) if(KeyScan() == KEY0) xTaskNotify(task2_handle, // 要发送的任务句柄 100, // 要发送的数据 eSetValueWithOverwrite // 发送方式 ); UartSendData(KEY0 PRESS!\\r ); vTaskDelay(200); /* * 函数作用：模拟消息队列接收 * 输入参数：无 * 返回值：无 * 作者：LSK*/void Task2(void) uint32_t res_notify; while(1) xTaskNotifyWait( 0x00000000, // 接收通知前是否清楚通知值，按位，全为0表示不不清楚 0xffffffff, // 接收通知后是否要清楚通知值，按位，全为f表示清楚 res_notify, // 接受值存放地址 portMAX_DELAY // 等待事件 ); sprintf(str, task2 notify: %d\\r , res_notify); UartSendData(str); 11.3 模拟事件标志组#include main.h#include portmacro.h#include projdefs.h#include stdint.hvoid StartTask(void);void Task1(void);void Task2(void);void FreeRTOS_Start(void);int main(void) // 初始化HAL库函数必须要调用此函数 HAL_Init(); // 系统时钟即AHB/APB时钟配置 SystemClock_Config(); // 初始化LED LedInit(); KeyInit(); UartInit(115200); FreeRTOS_Start(); while(1) HAL_Delay(1000); UartSendData(hello\\r ); LED_TOGGLE(LED0_GPIO_PORT,LED0_GPIO_PIN); /* 任务句柄，用以保存不同任务的配置 */TaskHandle_t start_task_handle;TaskHandle_t task1_handle;TaskHandle_t task2_handle;/* * 函数作用：常规写法，起始任务，用以创建其他任务 * 输入参数：无 * 返回值：无 * 作者：LSK*/void FreeRTOS_Start(void) xTaskCreate( (TaskFunction_t) StartTask, //任务函数的地址 (char *) StartTask, //任务函数的名称 (uint16_t) 128, //任务函数栈空间大小 (void *) NULL, //任务函数的参数 (UBaseType_t) 1, //任务函数的优先级 (TaskHandle_t*) start_task_handle //任务函数的句柄 ); /* 启用调度器，负责任务切换*/ vTaskStartScheduler();char str[100];void StartTask(void) /* 进入临界保护区，保证在临界区的代码不会被打断*/ taskENTER_CRITICAL(); xTaskCreate( (TaskFunction_t) Task1, (char *) Task1, (uint16_t) 128, (void *) NULL, (UBaseType_t) 3, (TaskHandle_t*) task1_handle ); xTaskCreate( (TaskFunction_t) Task2, (char *) Task2, (uint16_t) 128, (void *) NULL, (UBaseType_t) 4, (TaskHandle_t*) task2_handle ); vTaskDelete(NULL); //删除任务本身 /* 退出临界保护区*/ taskEXIT_CRITICAL();/* * 函数作用：模拟事件标志组发送 * 输入参数：无 * 返回值：无 * 作者：LSK*/void Task1(void) EventBits_t res; while(1) if (KeyScan() == KEY0) xTaskNotify(task2_handle, // 要发送的任务句柄 1 8, // 要发送的数据位 eSetBits // 发送方式 ); UartSendData(KEY0 PRESS!\\r ); vTaskDelay(200); /* * 函数作用：模拟事件标志组接收 * 输入参数：无 * 返回值：无 * 作者：LSK*/void Task2(void) uint32_t res_notify; while (1) xTaskNotifyWait( 0x00000000, // 接收通知前是否清楚通知值，按位，全为0表示不不清楚 0xffffffff, // 接收通知后是否要清楚通知值，按位，全为f表示清楚 res_notify, // 接受值存放地址 portMAX_DELAY // 等待时间 ); sprintf(str, task2 notify: %0x\\r , res_notify); UartSendData(str); 12、软件定时器#include main.h#include stdint.hvoid StartTask(void);void Task1(void);void FreeRTOS_Start(void);int main(void) // 初始化HAL库函数必须要调用此函数 HAL_Init(); // 系统时钟即AHB/APB时钟配置 SystemClock_Config(); // 初始化LED LedInit(); KeyInit(); UartInit(115200); FreeRTOS_Start();/* 任务句柄，用以保存不同任务的配置 */TaskHandle_t start_task_handle;TaskHandle_t task1_handle;/* * 函数作用：常规写法，起始任务，用以创建其他任务 * 输入参数：无 * 返回值：无 * 作者：LSK*/void FreeRTOS_Start(void) xTaskCreate( (TaskFunction_t) StartTask, //任务函数的地址 (char *) StartTask, //任务函数的名称 (uint16_t) 128, //任务函数栈空间大小 (void *) NULL, //任务函数的参数 (UBaseType_t) 1, //任务函数的优先级 (TaskHandle_t*) start_task_handle //任务函数的句柄 ); /* 启用调度器，负责任务切换*/ vTaskStartScheduler();char str[100];void TimerCallBack_1(TimerHandle_t timer);TimerHandle_t timer_handle_1;/* * 函数作用：开始任务回调函数 * 输入参数：无 * 返回值：无 * 作者：LSK*/void StartTask(void) /* 创建软件定时器，由软件定时器任务（通过定义宏，由系统创建）控制*/ timer_handle_1 = xTimerCreate(time_1, // 创建名称 500, // 定时器延迟时间 pdTRUE, // 是否重载（周期/一次） (void *)1, // 定时器唯一ID TimerCallBack_1 // 定时器回调函数 ); /* 进入临界保护区，保证在临界区的代码不会被打断*/ taskENTER_CRITICAL(); xTaskCreate((TaskFunction_t)Task1, (char *)Task1, (uint16_t)128, (void *)NULL, (UBaseType_t)3, (TaskHandle_t *)task1_handle); vTaskDelete(NULL); // 删除任务本身 /* 退出临界保护区*/ taskEXIT_CRITICAL();/* * 函数作用：开启软件定时器 * 输入参数：无 * 返回值：无 * 作者：LSK*/void Task1(void) EventBits_t res; while (1) if (KeyScan() == KEY0) /* 开启软件定时器*/ xTimerStart(timer_handle_1, // 定时器句柄 portMAX_DELAY); // 等待时间 UartSendData((timer start!\\r )); vTaskDelay(200); /* * 函数作用：定时器回调函数 * 输入参数：定时器句柄 * 返回值：无 * 作者：LSK*/void TimerCallBack_1(TimerHandle_t timer) if(timer == timer_handle_1) UartSendData(Call back!\\r ); LED_TOGGLE(LED0_GPIO_PORT, LED0_GPIO_PIN);","tags":["FreeRTOS"],"categories":["MCU开发"]},{"title":"ubuntu使用命令","path":"/Linux/ubuntu使用命令/","content":"重启 sudo reboot 关机 sudo poweroff 返回 1.返回根目录cd2.返回上一级cd ..3.回到上一次的位置cd - 列出当前目录文件 1.显示当前文件目录ls2.显示指定文件目录ls path3.显示所有文件ls -a4.显示文件属性ls -l5.显示所有文件属性ls -al或者ls -la 清楚终端 clear 显示当前路径 pwd 文件操作 1.创建文件夹mkdir document2.创建多级文件夹mkdir -p user/document3.删除文件夹rm -rf document4.复制文件夹cp document new_name5.创建文件touch 1.txt6.删除文件rm 1.txt 7.重命名或者移动mv aim new 环境变量 一，用户环境变量/user/ubuntu/.profile中添加shell脚本二，系统脚本在/etc/profile.d/目录下创建一个自定义脚本三，PATH环境变量echo $PATH 查看PATH环境变量在系统脚本下添加以下命令export PATH=$PATH:脚本路径 自动补全 tabtab tab vim 清空文件内容:%d 查看ip hostname -I 模式切换 1.开机默认进入命令行sudo systemctl set-default multi-user.target 2.开机默认进入桌面sudo systemctl set-default graphical.target 解压缩 归档文件tar -cvf name.tar file1 file2还原文件tar -xvf name.tartar -xvf name.tar -C path压缩文件tar -zcvf name.tar.gz file1 file2解压文件tar -zxvf name.tartar -zxvf name.tar -C path 创建软链接 创建软链接ln -s 操作对象 链接名字 用户操作 创建用户sudo useradd -m 用户名删除用户sudo userdel 用户名 修改用户密码sudo password 用户 修改文件权限 增加可执行权限chmod +x file增加可读权限chmod +r file增加可写权限chmod +w file 可执行脚本 shell脚本.sh文件，第一行声明shell解释器 #！/bin/sh添加可执行权限输入文件路径执行python脚本.python文件，第一行声明python解释器 #！/bin/python3添加可执行权限输入文件路径执行 ROS程序编译基础 自定义空间名spacemkdir -p ws/src进入space执行编译catkin_make在src目录下创建包，添加依赖catkin_create_pkg car_project roscpp rospy std_msgs1，C++部分：在包的src目录下创建编写C++文件修改CMakeLists.txt文件修改行136、149add_executable(name src/name.cpp)target_link_libraries(name $catkin_LIBRARIES)编译启动核心：roscore修改环境变量：source ./devel/setup.bashrosrun 包名 name2.python部分：在包下建立scripts文件存放python为python添加可执行条件：chmod +x name.py查看可执行权限：ll修改CMakeLists.txt文件修改行162：catkin_install_python(PROGRAMS scripts/自定义文件名.py DESTINATION $CATKIN_PACKAGE_BIN_DESTINATION)编译启动核心：roscore修改环境变量：source ./devel/setup.bashrosrun 包名 name.py wifi配置 #network-config文件version: 2wifis: renderer: networkd wlan0: dhcp4: true optional: true access-points: lsksp: password: 12345678 lsk: password: 12345678#sudo nano /etc/netplan/50-cloud-init.yamlnetwork: ethernets: eth0: dhcp4: true optional: true wifis: wlan0: optional: true access-points: WiFi名: password: 你wifi的密码 dhcp4: true version: 2#自定义network: ethernets: eth0: dhcp4: true optional: true wifis: wlan0: optional: true access-points: lsk: password: 12345678 lsksp: password: 12345678 addresses: [192.168.167.8/24] gateway4: 192.168.167.1 nameservers: addresses: [8.8.8.8, 144.144.144.144] dhcp4: true version: 2 查看进程并结束 #查看ps aux | grep -i apt#杀掉进程sudo kill process_id apt软件管理工具 安装软件apt install 软件名卸载软件apt remove 软件名搜索apt search xxx列表apt list | grep xxx","tags":["ubuntu"],"categories":["Linux"]},{"title":"Typora使用命令","path":"/工具使用/Typora使用命令/","content":"一、标题一级标题# 名称六级标题###### 名称----------------------------------------------一级标题ctrl + 1六级标题ctrl + 6清楚标题ctrl + 0 二、有序列表1. 名称ctrl + shift +[降级tab升级shift + tab 三、无序列表* 名称- 名称 四、任务列表- [ ] 名称 五、表格|名称|名称|名称| 六、代码行内代码`内容`代码块```语言类型~~~语言类型-------------------------------------------------代码块ctrl + shift + k 七、图片选择图片![]() 八、超链接超链接[显示](位置/链接) 九、水平分割线分割线--- 十、引用引用 内容 其他加粗ctrl + b斜体ctrl + i高亮==内容==","tags":["Typora"],"categories":["工具使用"]},{"title":"使用VScode开发STM32:基于CMake","path":"/工具使用/使用VScode开发STM32基于CMake/","content":"使用VScode开发STM32:基于CMake本教程使用VScode作为代码编辑工具、使用Cmake作为构建系统生成器、Make进行构建系统、使用arm-none-eabi-gcc进行交叉编译、使用OpenOCD作为代码下载与调试工具，最终搭建出适用于ARM架构系列芯片的开发环境。此教程以STM32F103ZET6芯片为例，演示LED灯闪烁的项目。 经验证，可满足基本基本项目需求。同时由于arm-none-eabi-gcc编译器相比于keil的AC5、AC6编译器，所编译的hex文件比较大，Flash占用较高，为了兼顾keil开发项目，也为了能够与其他人的项目兼容，这里的keil与VScode的项目文件互不干扰，满足兼容性需求。 本文涉及的软件安装包、工程模板已放在我的百度网盘中，需要自取。 链接：https://pan.baidu.com/s/1pO-5R3Li5NIfctx3UzaPig?pwd=ts91 提取码：ts91 --来自百度网盘超级会员V4的分享 一、软件安装已默认电脑上存在VScode，这里不讲述Vscode的安装。 涉及软件的安装配置： 安装Cmake 安装arm-none-eabi-gcc 安装OpenOCD MinGW 安装VScode插件CC++、CMake、Cortex-Debug 1.1 安装CMake1.1.1 安装下载地址： https://cmake.org/download/ 选择适合自己电脑的最新版本进行下载并安装，我这里选择cmake-3.29.2-windows-x86_64.msi，如下图： 1.1.2 添加环境变量我们需要将cmake的可执行文件的文件夹路径添加到环境变量，方便使用命令调用cmake，我的路径为： D:\\RJ\\CMake\\bin 将以上目录添加到系统环境变量中去。 1.1.3 验证在终端输入以下命令，验证是否安装成功。 cmake 成功则将显示以下内容： 1.2 安装arm-none-eabi-gcc1.2.1 安装下载地址： https://developer.arm.com/downloads/-/gnu-rm 选择适合自己电脑的最新版本进行下载并安装，我这里选择gcc-arm-none-eabi-10.3-2021.10-win32.exe，如下图： 1.2.2 添加环境变量我们需要将arm-gcc的可执行文件的文件夹路径添加到环境变量，方便使用命令调用arm-gcc，我的路径为: D:\\RJ\\ARM-GCC\\10 2021.10\\bin 将以上目录添加到系统环境变量中去。 1.2.3 验证在终端输入以下命令，验证是否安装成功。 arm-none-eabi-gcc 成功则将显示以下内容： 1.3 安装OpenOCD1.3.1 安装下载地址： https://gnutoolchains.com/arm-eabi/openocd/ 选择适合自己电脑的最新版本进行下载，直接下载的是压缩包文件，解压后可直接使用，我这里选择openocd-20231002.7z，如下图： 1.3.2 添加环境变量我们需要将OpenOCD的可执行文件的文件夹路径添加到环境变量，方便使用命令调用OpenOCD，我的路径为: D:\\RJ\\OpenOCD-20231002-0.12.0\\bin 将以上目录添加到系统环境变量中去。 1.3.3 验证在终端输入以下命令，验证是否安装成功。 openOCD 成功则将显示以下内容： 1.4 安装MinGW1.4.1 安装下载地址： https://sourceforge.net/projects/mingw-w64/files/ 选择适合自己电脑的最新版本进行下载，直接下载的是压缩包文件，解压后的mingw64可直接使用，我这里选择MinGW-W64GCC-8.1.0下的x86_64-posix-sjlj，如下图： 1.4.2 添加环境变量我们需要将make的可执行文件的文件夹路径添加到环境变量，方便使用命令调用make，我的路径为: D:\\RJ\\mingw64\\bin 将以上目录添加到系统环境变量中去。 1.3.3 验证在终端输入以下命令，验证是否安装成功(由于Window下make执行程序为mingw32-make.exe，我这里将其复制保存同目录下为副本，并改名为make.exe)。 make 成功则将显示以下内容： 1.5 在Vscode中安装插件要安装的插件如下： 二、工程搭建以下是我的工程框架 与ARM-MDK工程不同，我们配置工程还需要格外的文件，分别是CMakeLists.txt、startup_stm32f10x_hd.s、STM32F103ZETx_FLASH.ld。 2.1 配置CMakeLists.txt文件CMake根据CMakeLists.txt进行构建，从而创建出Makefile，再由make根据 Makefile 定义的规则调用 GCC 执行编译工作，最终生成可执行的.elf或者.hex文件。以下是CMakeLists.txt的模板，需要更改的部分我已经标明。 #THIS FILE IS AUTO GENERATED FROM THE TEMPLATE! DO NOT CHANGE!set(CMAKE_SYSTEM_NAME Generic)set(CMAKE_SYSTEM_VERSION 1)cmake_minimum_required(VERSION 3.20) # specify cross compilers and toolsset(CMAKE_C_COMPILER arm-none-eabi-gcc)set(CMAKE_CXX_COMPILER arm-none-eabi-g++)set(CMAKE_ASM_COMPILER arm-none-eabi-gcc)set(CMAKE_AR arm-none-eabi-ar)set(CMAKE_OBJCOPY arm-none-eabi-objcopy)set(CMAKE_OBJDUMP arm-none-eabi-objdump)set(SIZE arm-none-eabi-size)set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY) # project settingsproject(Project C CXX ASM)set(CMAKE_CXX_STANDARD 17)set(CMAKE_C_STANDARD 11) #Uncomment for hardware floating point#add_compile_definitions(ARM_MATH_CM4;ARM_MATH_MATRIX_CHECK;ARM_MATH_ROUNDING)#add_compile_options(-mfloat-abi=hard -mfpu=fpv4-sp-d16)#add_link_options(-mfloat-abi=hard -mfpu=fpv4-sp-d16) #Uncomment for software floating point#add_compile_options(-mfloat-abi=soft) add_compile_options(-mcpu=cortex-m3 -mthumb -mthumb-interwork)add_compile_options(-ffunction-sections -fdata-sections -fno-common -fmessage-length=0) # uncomment to mitigate c++17 absolute addresses warnings#set(CMAKE_CXX_FLAGS $CMAKE_CXX_FLAGS -Wno-register)if ($CMAKE_BUILD_TYPE STREQUAL Release) message(VERBOSE Maximum optimization for speed) add_compile_options(-Ofast)elseif ($CMAKE_BUILD_TYPE STREQUAL RelWithDebInfo) message(VERBOSE Maximum optimization for speed, debug info included) add_compile_options(-Ofast -g)elseif ($CMAKE_BUILD_TYPE STREQUAL MinSizeRel) message(VERBOSE Maximum optimization for size) add_compile_options(-Os)else () message(VERBOSE Minimal optimization, debug info included) add_compile_options(-Og -g)endif ()#添加宏定义add_definitions(-DUSE_HAL_DRIVER -DSTM32F103xB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD)#添加头文件路径，即.h文件include_directories(./STM32F10x_FWLib/inc ./User ./Project/Code-Cmake)#添加源文件路径,即.c或者.s文件file(GLOB_RECURSE SOURCES ./STM32F10x_FWLib/src/*.c ./User/*.c ./Project/Code-Cmake/*.*)#添加你的STM32F103ZETx_FLASH.ld的连接脚本路径set(LINKER_SCRIPT $CMAKE_SOURCE_DIR/Project/Code-Cmake/STM32F103ZETx_FLASH.ld) add_link_options(-Wl,-gc-sections,--print-memory-usage,-Map=$PROJECT_BINARY_DIR/$PROJECT_NAME.map)#选择cortex-m3内核add_link_options(-mcpu=cortex-m3 -mthumb -mthumb-interwork)add_link_options(-T $LINKER_SCRIPT) add_link_options(-specs=nano.specs -specs=nosys.specs -u _printf_float) add_executable($PROJECT_NAME.elf $SOURCES $LINKER_SCRIPT) set(HEX_FILE $PROJECT_BINARY_DIR/$PROJECT_NAME.hex)set(BIN_FILE $PROJECT_BINARY_DIR/$PROJECT_NAME.bin) add_custom_command(TARGET $PROJECT_NAME.elf POST_BUILD COMMAND $CMAKE_OBJCOPY -Oihex $TARGET_FILE:$PROJECT_NAME.elf $HEX_FILE COMMAND $CMAKE_OBJCOPY -Obinary $TARGET_FILE:$PROJECT_NAME.elf $BIN_FILE COMMENT Building $HEX_FILEBuilding $BIN_FILE) 2.2 选择startup_stm32f10x_hd.s在我们创建ARM-MDK工程时，我们从官方的固件包中选择的是arm版本的启动文件，在这里我们要选择gcc版本的启动文件，即下图中的gcc_ride7。同时为了与ARM-MDK有所区分，我将该文件放在了ProjectCode-Cmake文件夹下。 2.3 STM32F103ZETx_FLASH.ldSTM32F103ZETx_FLASH.ld是一个链接脚本文件，它告诉编译器相关的编译后的可执行代码，内存变量，中断向量，链接在哪个存储区。获取方式主要有三种（请根据自己单片机型号选择）： 使用CudeMax编译过程可以生成该链接脚本 搜索已有的工程，你可以直接在浏览器搜索STM32F103ZETx_FLASH.ld，一般都有。 如果你对该型号芯片足够了解，可以自行编写。 以下是我的STM32F103ZETx_FLASH.ld: /*********************************************************************************** @file : LinkerScript.ld**** @author : Auto-generated by STM32CubeIDE**** @brief : Linker script for STM32F103ZETx Device from STM32F1 series** 512Kbytes FLASH** 64Kbytes RAM**** Set heap size, stack size and stack location according** to application requirements.**** Set memory bank area and size if external memory is used**** Target : STMicroelectronics STM32**** Distribution: The file is distributed as is, without any warranty** of any kind.********************************************************************************** @attention**** h2centercopy; Copyright (c) 2021 STMicroelectronics.** All rights reserved./center/h2**** This software component is licensed by ST under BSD 3-Clause license,** the License; You may not use this file except in compliance with the** License. You may obtain a copy of the License at:** opensource.org/licenses/BSD-3-Clause*********************************************************************************//* Entry Point */ENTRY(Reset_Handler)/* Highest address of the user mode stack */_estack = ORIGIN(RAM) + LENGTH(RAM); /* end of RAM Ram type memory */_Min_Heap_Size = 0x200 ; /* required amount of heap */_Min_Stack_Size = 0x400 ; /* required amount of stack *//* Memories definition */MEMORY RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 64K FLASH (rx) : ORIGIN = 0x8000000, LENGTH = 512K/* Sections */SECTIONS /* The startup code into FLASH Rom type memory */ .isr_vector : . = ALIGN(4); KEEP(*(.isr_vector)) /* Startup code */ . = ALIGN(4); FLASH /* The program code and other data into FLASH Rom type memory */ .text : . = ALIGN(4); *(.text) /* .text sections (code) */ *(.text*) /* .text* sections (code) */ *(.glue_7) /* glue arm to thumb code */ *(.glue_7t) /* glue thumb to arm code */ *(.eh_frame) KEEP (*(.init)) KEEP (*(.fini)) . = ALIGN(4); _etext = .; /* define a global symbols at end of code */ FLASH /* Constant data into FLASH Rom type memory */ .rodata : . = ALIGN(4); *(.rodata) /* .rodata sections (constants, strings, etc.) */ *(.rodata*) /* .rodata* sections (constants, strings, etc.) */ . = ALIGN(4); FLASH .ARM.extab : . = ALIGN(4); *(.ARM.extab* .gnu.linkonce.armextab.*) . = ALIGN(4); FLASH .ARM : . = ALIGN(4); __exidx_start = .; *(.ARM.exidx*) __exidx_end = .; . = ALIGN(4); FLASH .preinit_array : . = ALIGN(4); PROVIDE_HIDDEN (__preinit_array_start = .); KEEP (*(.preinit_array*)) PROVIDE_HIDDEN (__preinit_array_end = .); . = ALIGN(4); FLASH .init_array : . = ALIGN(4); PROVIDE_HIDDEN (__init_array_start = .); KEEP (*(SORT(.init_array.*))) KEEP (*(.init_array*)) PROVIDE_HIDDEN (__init_array_end = .); . = ALIGN(4); FLASH .fini_array : . = ALIGN(4); PROVIDE_HIDDEN (__fini_array_start = .); KEEP (*(SORT(.fini_array.*))) KEEP (*(.fini_array*)) PROVIDE_HIDDEN (__fini_array_end = .); . = ALIGN(4); FLASH /* Used by the startup to initialize data */ _sidata = LOADADDR(.data); /* Initialized data sections into RAM Ram type memory */ .data : . = ALIGN(4); _sdata = .; /* create a global symbol at data start */ *(.data) /* .data sections */ *(.data*) /* .data* sections */ *(.RamFunc) /* .RamFunc sections */ *(.RamFunc*) /* .RamFunc* sections */ . = ALIGN(4); _edata = .; /* define a global symbol at data end */ RAM AT FLASH /* Uninitialized data section into RAM Ram type memory */ . = ALIGN(4); .bss : /* This is used by the startup in order to initialize the .bss section */ _sbss = .; /* define a global symbol at bss start */ __bss_start__ = _sbss; *(.bss) *(.bss*) *(COMMON) . = ALIGN(4); _ebss = .; /* define a global symbol at bss end */ __bss_end__ = _ebss; RAM /* User_heap_stack section, used to check that there is enough RAM Ram type memory left */ ._user_heap_stack : . = ALIGN(8); PROVIDE ( end = . ); PROVIDE ( _end = . ); . = . + _Min_Heap_Size; . = . + _Min_Stack_Size; . = ALIGN(8); RAM /* Remove information from the compiler libraries */ /DISCARD/ : libc.a ( * ) libm.a ( * ) libgcc.a ( * ) .ARM.attributes 0 : *(.ARM.attributes) 2.4 关于core_cm3.c文件由于gcc编译的问题，如果不更改core_cm3.c，可能出现以下报错： 我对此做出以下两处更改，并放在了ProjectCode-Cmake文件夹下，与MDK-ARM分开： 2.5 配置.vscode文件夹这是VScode配置文件的位置 2.4.1 添加并配置c_cpp_properties.json将其CC++模式更改为gcc-arm，注意将gcc路径替换为自己的路径 configurations: [ name: Win32, includePath: [ $workspaceFolder/** ], defines: [ _DEBUG, UNICODE, _UNICODE ], compilerPath: D:\\\\RJ\\\\mingw64\\\\bin\\\\gcc.exe, cStandard: gnu17, cppStandard: gnu++14, intelliSenseMode: gcc-arm, configurationProvider: ms-vscode.cmake-tools ], version: 4 2.4.1 添加并配置launch.json 这个文件是关于烧录与调试相关的，在此目录下你可以选择你的下载器型号、芯片型号。其中的stm32f103.svd可以在调试时查看看寄存器的值，请将以下路径改为自己工程的路径。 // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 version: 0.2.0, configurations: [ cwd: $workspaceRoot, executable: D:/GC/STM32F1/build/Project.elf, name: Debug with OpenOCD, request: launch, type: cortex-debug, servertype: openocd, configFiles: [ D:/RJ/OpenOCD-20231002-0.12.0/share/openocd/scripts/interface/stlink-v2.cfg, //在OpenOCD选择下载器 D:/RJ/OpenOCD-20231002-0.12.0/share/openocd/scripts/target/stm32f1x.cfg //在OpenOCD选择芯片 ], svdFile: D:/GC/STM32F1/stm32f103.svd, //选择寄存器文件 ] 三、编译、下载与调试如果我们配置完成后，用VScode打开CMakeLists.txt所在文件夹工程过后，Cmake tool会自动提示配置Cmake，点击配置后，会生成build文件夹，产生的Makefile及其他中间文件会存放在该目录。 3.1 选择编译器点击VScode下方的配置按钮，选择gcc-arm 3.2 编译点击VScode下方的进行编译，生成目标文件 编译过程 在build文件夹下会生成目标文件 3.3 烧录进入build文件夹下执行以下命令,其中将Project.hex替换为自己的目标文件，stlink-v2.cfg是选择下载器类型，stm32f1x.cfg是芯片型号 openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg -c program Project.hex verify reset exit 烧录成功 3.3 调试打开左侧的运行和调试，选择Debug with OpenOCD 点击运行，可进行断点调试，变量监测，寄存器查看等操作。 3.4 关于变量定义使用gcc编译时，我们一般需要告诉编译器这个变量是可变的，不然会造成内存覆盖，程序无法运行的情况，即voatile关键词 四、参考链接 此文章参考以下文章，若描述不清，可查看下方文章 Vscode搭建开发调试STM32RISC-V环境IDE(最全面) VSCode 和 CMake 搭建嵌入式开发环境","tags":["VScode"],"categories":["工具使用"]},{"title":"数据结构与算法","path":"/再探C语言/数据结构与算法/","content":"一、数据结构与算法：线性表1、顺序表实现代码： #include stdio.h#include stdlib.htypedef int E; //定义顺序表存储的数据为intstruct List E *array; //实现顺序表的底层数组 int capacity; //表示底层数组的容量 int size; //已存多少数据;//插入元素_Bool insertList(struct List *list, E element, int index) if (index 1 || index list-size + 1) return 0; //index可能非法 if(list-size == list-capacity) //判断顺序表是否满了，若满，则扩容。 int newCapacity = list-capacity + (list-capacity 1); //1 相当于/2 E * newList = realloc(list-array, newCapacity*sizeof(E)); if(newList == NULL) return 0; list-array = newList; list-capacity = newCapacity; for (int i = list-size; i=index; --i) list-array[i] = list-array[i-1]; list-array[index - 1] = element; list-size++; return 1;//删除元素_Bool deleteList(struct List *list,int index) if(index 1 || index list-size) return 0; for(int i = index - 1; i list-size - 1; ++i) list-array[i] = list-array[i+1]; list-size--;//活得顺序表大小int sizeList(struct List *list) return list-size;//获得元素E * getList(struct List *list, int index) if(index 1 || index list-size) return NULL; return list-array[index-1];//查找元素int findList(struct List *list,E element) for(int i = 0; i list-size; i++) if(list-array[i] == element) return i + 1; return -1;/******/_Bool initList(struct List *list ) list-array = malloc(sizeof(E)*10); //malloc开辟的内存在堆区，函数生命周期结束后还存在（需要手动释放或程序结束后由系统释放）。 if (list-array == NULL) return 0; //若申请内存空间失败，则返回0. list-capacity = 10; list-size = 0; return 1;void printList(struct List *list) for(int i = 0; ilist-size; ++i) printf(%d , list-array[i]); printf( );int main(int argc,int* argv) struct List * list = malloc(sizeof(struct List *)); /*结构体指针初始化，首先不能 “= NULL”，因为指针指向一个安全的区域，不能解析。 **也不能，不初始化，因为指针可能指向未知地址，对其操作造成的后果是未知的， **初始化方式有：一、在堆区开辟一个空间；二、先定义一个结构体，用指针指向他； */ if(initList(list)) for(int i = 0; i10; ++i) insertList(list,i*10,i+1); deleteList(list,2); printList(list); printf(%d ,*getList(list,2)); printf(%d,findList(list,30)); else printf(shibai); free(list); 顺序表是一种随机存取的存储结构。 2、链表实现代码： #include stdio.h#include stdlib.htypedef int E; //定义顺序表存储的数据为intstruct ListNode E element; struct ListNode *next;;typedef struct ListNode* Node;void initList(Node node) node-next = NULL;_Bool insertList(Node head, E element, int index) if(index 0) return 0; while(--index) head = head-next; if(head == NULL) return 0; Node node = malloc(sizeof(struct ListNode)); if(node == NULL) return 0; node-element = element; node-next = head-next; head-next = node; return 1;_Bool deleteList(Node head, int index) if(index 1) return 0; while(--index) head = head-next; if(head == NULL) return 0; if(head-next == NULL) return 0; Node node = head-next; head-next = head-next-next; free(node); return 1;//获得元素；E *getList(Node head, int index) if(index 1) return 0; if (head-next == NULL) return NULL; //若为空表，则返回为空； do head = head-next; if(head == NULL) return NULL; while(--index); return head-element;//寻找元素下标int findList(Node head, E element) int i = 1; if(head-next == NULL) return -1; //判断是否为空表 do head = head-next; if(head-element == element) return i; i++; while(head-next); return -1;int sizeList(Node head) int i = 0; while(head-next) i++; head = head-next; return i;//函数都是值传递，传值，值不变；传指针，指针不变；传指针，值会变//对head-element或者head-next操作会改变值void printfList(Node head) while(head-next) head = head-next; printf(%d ,head-element); printf( );int main() Node p1; struct ListNode head; initList(head); for(int i = 0; i 3; ++i) insertList(head,i*10, i+1); printfList(head); printf(%d,sizeList(head)); 链表表是一种顺序访问的存储结构。 3、双向链表4、循环链表w5、堆栈（Stack）先进后出 6、队列（Queue）先进先出 实战1、反转链表题目描述：给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 解法一#include stdio.h#include stdlib.htypedef int E; //定义顺序表存储的数据为intstruct ListNode int val; struct ListNode *next;;struct ListNode* reverseList(struct ListNode* head) struct ListNode *tmp,*newHead = NULL; while (head) //假设前面已被反转。 tmp = head-next;\t//保存第二个节点，用于当作下一个节点的头结点。 head-next = newHead;\t//指向前节点 newHead = head;\t//更新前节点 head = tmp;\t//新链表 return newHead; 解法二:递归#include stdio.h#include stdlib.htypedef int E; //定义顺序表存储的数据为intstruct ListNode int val; struct ListNode *next;;struct ListNode* reverseList(struct ListNode* head) if (head == NULL || head-next == NULL) return head; struct ListNode* newHead = reverseList(head-next); head-next-next = head; head-next = NULL; return newHead; 实战2、匹配字符串给定一个只包括 (，)，{，}，[，] 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 方法：栈的应用方法1：自己的#includestdio.h#includestring.h#includestdlib.h#define true 1#define false 0typedef char E;struct LNode E val; struct LNode *next;;typedef struct LNode* Node;void initStack(Node head) head-next = NULL;void printStack(Node head) printf(| ); head = head-next; while (head) printf(%d , head-val); head = head-next; printf( );//入栈_Bool pushStack(Node head, E val) Node node = malloc(sizeof(struct LNode)); if(node == NULL) return 0; node-next = head-next; node-val = val; head-next = node; return 1;//出栈E popStack(Node head) if(head-next == NULL) return 0; Node node; node = head-next; E val = node-val; head-next = head-next-next; free(node); return val; _Bool isValid(char* s) struct LNode head; initStack(head); unsigned int len = strlen(s); if(len % 2 == 1) return false; pushStack(head,s[0]); for(int i = 1; i len; i++) E top = popStack(head); if(top != 0)pushStack(head,top); if(top == () if(s[i] == )) popStack(head); else pushStack(head,s[i]); else if(top == [) if(s[i] == ]) popStack(head); else pushStack(head,s[i]); else if(top == ) if(s[i] == ) popStack(head); else pushStack(head,s[i]); else pushStack(head,s[i]); if(head.next == NULL) return true; else return false;int main() char *s = ()[]; printf(%d ,isValid(s)); 方法2：更快#include stdlib.h#include stdbool.h#include string.htypedef char E;struct LNode E element; struct LNode * next;;typedef struct LNode * Node;void initStack(Node head) head-next = NULL;_Bool pushStack(Node head, E element) Node node = malloc(sizeof(struct LNode)); if(node == NULL) return 0; node-next = head-next; node-element = element; head-next = node; return 1;_Bool isEmpty(Node head) return head-next == NULL;E popStack(Node head) Node top = head-next; head-next = head-next-next; E e = top-element; free(top); return e;bool isValid(char * s) unsigned long len = strlen(s); if(len % 2 == 1) return false; //如果长度不是偶数，那么一定不能成功匹配 struct LNode head; initStack(head); for (int i = 0; i len; ++i) char c = s[i]; if(c == ( || c == [ || c == ) pushStack(head, c); else if(isEmpty(head)) return false; if(c == )) if(popStack(head) != () return false; else if(c == ]) if(popStack(head) != [) return false; else if(popStack(head) != ) return false; return isEmpty(head); 方法三：更快char pairs(char a) if (a == ) return ; if (a == ]) return [; if (a == )) return (; return 0;bool isValid(char* s) int n = strlen(s); if (n % 2 == 1) return false; int stk[n + 1], top = 0; for (int i = 0; i n; i++) char ch = pairs(s[i]); if (ch) if (top == 0 || stk[top - 1] != ch) return false; top--; else stk[top++] = s[i]; return top == 0; 二、数据结构与算法：树1、树：理论 我们一般称位于最上方的结点为树的根结点（Root）； 每个结点连接的子结点数目（分支的数目），我们称为结点的度（Degree），而各个结点度的最大值称为树的度； 每个结点延伸下去的下一个结点都可以称为一棵子树（SubTree）； 每个结点的层次（Level）按照从上往下的顺序，树的根结点为1，每向下一层+1，比如G的层次就是3，整棵树中所有结点的最大层次，就是这颗树的深度（Depth）； 与当前结点直接向下相连的结点，我们称为子结点（Child）；相反即为父节点； 如果某个节点没有任何的子结点（结点度为0时）那么我们称这个结点为叶子结点； 如果两个结点的父结点是同一个，那么称这两个节点为兄弟结点（Sibling）； 从根结点开始一直到某个结点的整条路径的所有结点，都是这个结点的祖先结点（Ancestor）； 2、二叉树的性质 性质一： 对于一棵二叉树，第i层的最大结点数量为 个2^i - 1; 一棵深度为k的二叉树最大结点数量为 n 2^k*−1，顺便得出，结点的边数为 E n - 1。 于任何一棵二叉树，如果其叶子结点个数为 n0，度为2的结点个数为 n2 ，那么两者满足以下公式：n0 n2+1; n个结点的完全二叉树深度为 k log2^n + 1 ; 3、二叉树遍历：前序、中序、后序遍历 前序遍历结果为：ABDECF； 中序遍历结果为：DBEACF； 后序遍历结果为：DEBFCA； #includestdio.h#includestring.h#includestdlib.htypedef char E;struct TreeNode E element; struct TreeNode *left; struct TreeNode *right;;typedef struct TreeNode* Node;//前序递归，利用函数栈的特性，不断出栈入栈void preOrder(Node root) if(root == NULL) return; printf(%c, root-element); preOrder(root-left); preOrder(root-right);//中序遍历void inOrder(Node root) if(root == NULL) return; inOrder(root-left); printf(%c,root-element); inOrder(root-right);//后序遍历void afOrder(Node root) if(root == NULL) return; afOrder(root-left); afOrder(root-right); printf(%c,root-element);int main() Node a = malloc(sizeof(struct TreeNode)); Node b = malloc(sizeof(struct TreeNode)); Node c = malloc(sizeof(struct TreeNode)); Node d = malloc(sizeof(struct TreeNode)); Node e = malloc(sizeof(struct TreeNode)); Node f = malloc(sizeof(struct TreeNode)); a-element = A; b-element = B; c-element = C; d-element = D; e-element = E; f-element = F; a-left = b; a-right = c; b-left = d; b-right = e; c-right = f; c-left = NULL; d-left = e-right = NULL; e-left = e-right = NULL; f-left = f-right = NULL; afOrder(a); 4、二叉树遍历：层序遍历#includestdio.h#includestring.h#includestdlib.htypedef char E;typedef struct TreeNode E element; //存放元素 struct TreeNode * left; //指向左子树的指针 struct TreeNode * right; //指向右子树的指针 *Node;typedef struct initNode //定义队列初始节点 Node element; struct initNode *next; *INode;struct Queue //队列头尾指针 INode front,rear;;typedef struct Queue* LinkedQueue;_Bool initQueue(LinkedQueue queue) INode node = malloc(sizeof(struct initNode)); if(node == NULL) return 0; node-next = NULL; queue-front = queue-rear = node;//入队_Bool enQueue(LinkedQueue quene, Node element) INode node = malloc(sizeof(struct initNode)); if(node == NULL) return 0; node-next = NULL; node-element = element; quene-rear-next = node; quene-rear = node; return 1;// 出队Node deQueue(LinkedQueue queue) Node val = queue-front-next-element; INode node; node = queue-front-next; queue-front-next = queue-front-next-next; if(queue-rear == node) queue-rear = queue-front; free(node); return val;_Bool isEmpty(LinkedQueue queue) return (queue-front == queue-rear);void levelQueue(Node root) struct Queue queue; initQueue(queue); enQueue(queue,root); while(!isEmpty(queue)) Node node = deQueue(queue); printf(%c,node-element); if(node-left) enQueue(queue,node-left); if(node-right) enQueue(queue,node-right); int main() Node a = malloc(sizeof(struct TreeNode)); Node b = malloc(sizeof(struct TreeNode)); Node c = malloc(sizeof(struct TreeNode)); Node d = malloc(sizeof(struct TreeNode)); Node e = malloc(sizeof(struct TreeNode)); Node f = malloc(sizeof(struct TreeNode)); a-element = A; b-element = B; c-element = C; d-element = D; e-element = E; f-element = F; a-left = b; a-right = c; b-left = d; b-right = e; c-right = f; c-left = NULL; d-left = e-right = NULL; e-left = e-right = NULL; f-left = f-right = NULL; levelQueue(a); 5、二叉树的线索化(以前序为例)#includestdio.h#includestring.h#includestdlib.htypedef char E;typedef struct TreeNode E element; //存放元素 struct TreeNode * left; //指向左子树的指针 struct TreeNode * right; //指向右子树的指针 char leftFlag,rightFlag //线索化标志位 *Node;Node pre = NULL; //这里我们需要一个pre来保存后续结点的指向void treeOrdered(Node root) if(root == NULL) return; //线索化规则：结点的左指针，指向其当前遍历顺序的前驱结点；结点的右指针，指向其当前遍历顺序的后继结点。 if(root-left == NULL) //判断当前节点的左节点是否为空，若为空，则指向上一个节点。 root-leftFlag = 1; root-left = pre; if(pre pre-right == NULL) //判断上一个节点的右节点是否为空，若为空，则指向当前节点 pre-right = root; pre-rightFlag = 1; pre = root; if(root-leftFlag == 0) treeOrdered(root-left); //判断左节点是否是线索化的，若不是，才能继续。 if(root-rightFlag == 0) treeOrdered(root-right); //判断可略，因为，我们对右节点的线索化，是在后面执行的void preOrder(Node root) while (root) //到头为止 printf(%c, root-element); //因为是前序遍历，所以直接按顺序打印就行了 if(root-leftFlag == 0) root = root-left; //如果是左孩子，那么就走左边 else root = root-right; //如果左边指向是线索，那么就直接走右边。 Node createNode(E element) //单独写了个函数来创建结点 Node node = malloc(sizeof(struct TreeNode)); node-left = node-right = NULL; node-rightFlag = node-leftFlag = 0; node-element = element; return node;int main() Node a = createNode(A); Node b = createNode(B); Node c = createNode(C); Node d = createNode(D); Node e = createNode(E); a-left = b; b-left = d; a-right = c; b-right = e; treeOrdered(a); preOrder(a); 六、二叉搜索树（二叉查找树）七、平衡二叉树三、数据结构与算法：哈希表1、哈希表#includestdio.h#includestdlib.h#define SIZE 9//结构体指针，直接用E-key访问，避免用*E访问typedef struct Element //这里用一个Element将值包装一下 int key; //这里元素设定为int * E;typedef struct HashTable //这里把数组封装为一个哈希表 E * table; * HashTable;int hash(int key) //哈希函数 return key % SIZE;void init(HashTable hashTable) //初始化函数 hashTable-table = malloc(sizeof(struct Element) * SIZE); for (int i = 0; i SIZE; ++i) hashTable-table[i] = NULL;void insert(HashTable hashTable, E element) //插入操作，为了方便就不考虑装满的情况了 int hashCode = hash(element-key); //首先计算元素的哈希值 hashTable-table[hashCode] = element; //对号入座_Bool find(HashTable hashTable, int key) int hashCode = hash(key); //首先计算元素的哈希值 if(!hashTable-table[hashCode]) return 0; //如果为NULL那就说明没有 return hashTable-table[hashCode]-key == key; //如果有，直接看是不是就完事E create(int key) //创建一个新的元素 E e = malloc(sizeof(struct Element)); e-key = key; return e;int main() struct HashTable hashTable; init(hashTable); insert(hashTable, create(10)); insert(hashTable, create(7)); insert(hashTable, create(13)); insert(hashTable, create(29)); printf(%d , find(hashTable, 1)); printf(%d , find(hashTable, 13)); 2、哈希冲突（链地址法）#includestdio.h#includestdlib.h#define SIZE 9typedef struct ListNode //结点定义 int key; struct ListNode * next; * Node;typedef struct HashTable //哈希表 struct ListNode * table; //这个数组专门保存头结点 * HashTable;void init(HashTable hashTable) hashTable-table = malloc(sizeof(struct ListNode) * SIZE); for (int i = 0; i SIZE; ++i) hashTable-table[i].key = -1; //将头结点key置为-1，next指向NULL hashTable-table[i].next = NULL; int hash(int key) //哈希函数 return key % SIZE;Node createNode(int key) //创建结点专用函数 Node node = malloc(sizeof(struct ListNode)); node-key = key; node-next = NULL; return node;void insert(HashTable hashTable, int key) int hashCode = hash(key); Node head = hashTable-table + hashCode; //先计算哈希值，找到位置后直接往链表后面插入结点就完事了 while (head-next) head = head-next; head-next = createNode(key); //插入新的结点_Bool find(HashTable hashTable, int key) int hashCode = hash(key); Node head = hashTable-table + hashCode; while (head-next head-key != key) //直到最后或是找到为止 head = head-next; return head-key == key; //直接返回是否找到int main() struct HashTable table; init(table); insert(table, 10); insert(table, 19); insert(table, 20); printf(%d , find(table, 20)); printf(%d , find(table, 17)); printf(%d , find(table, 19));","tags":["C"],"categories":["再探C语言"]},{"title":"直角坐标系转化（python自制）","path":"/工具使用/直角坐标系转化（python自制）/","content":"将原始的坐标数据，转化成你希望的坐标系，python程序如下： import tkinter as tkfrom tkinter import ttk, messageboximport numpy as npimport sv_ttk # 添加在import部分class CoordinateTransformer:\tdef __init__(self, root): self.root = root self.root.title(坐标转换工具-LSK) # 设置全局默认字体（黑体 10号） self.root.option_add(*Font, (黑体, 10)) sv_ttk.set_theme(light) # 设置默认light主题 self.setup_ui() # 初始化数据 self.points = [] self.transformed_points = [] self.y_direction = 1 # 加载示例数据 self.load_sample_data() def setup_ui(self): 初始化现代化用户界面 self.root.geometry(900x600) main_frame = ttk.Frame(self.root, padding=10) main_frame.pack(fill=both, expand=True) # 左侧控制面板 control_frame = ttk.Frame(main_frame, width=250, padding=10) control_frame.pack(side=left, fill=y) # 右侧绘图区 plot_frame = ttk.Frame(main_frame, padding=10) plot_frame.pack(side=right, fill=both, expand=True) # 添加绘图区标题 plot_title = ttk.Label(plot_frame, text=坐标点分布图, font=(黑体, 10, bold)) plot_title.pack(side=top, pady=(0, 5)) # 画布容器保持不变 self.canvas = tk.Canvas(plot_frame, bg=white, bd=0, highlightthickness=0) self.canvas.pack(fill=both, expand=True) # 坐标输入区 input_frame = ttk.LabelFrame(control_frame, text=原始坐标, padding=10) input_frame.pack(fill=x, pady=5) self.coord_text = tk.Text(input_frame, height=10, width=30, font=(Consolas, 9)) self.coord_text.pack(fill=x) # 参考点设置 ref_frame = ttk.LabelFrame(control_frame, text=参考点设置, padding=10) ref_frame.pack(fill=x, pady=5) # 原点坐标(a) ttk.Label(ref_frame, text=原点(a) x,y:).grid(row=0, column=0, sticky=w) self.a_x = ttk.Entry(ref_frame, width=10, font=(Consolas, 10)) self.a_x.grid(row=0, column=1, padx=5, pady=2) self.a_y = ttk.Entry(ref_frame, width=10, font=(Consolas, 10)) self.a_y.grid(row=0, column=2, padx=5, pady=2) # x轴点坐标(b) ttk.Label(ref_frame, text=X 轴(b) x,y:).grid(row=1, column=0, sticky=w) self.b_x = ttk.Entry(ref_frame, width=10, font=(Consolas, 10)) self.b_x.grid(row=1, column=1, padx=5, pady=2) self.b_y = ttk.Entry(ref_frame, width=10, font=(Consolas, 10)) self.b_y.grid(row=1, column=2, padx=5, pady=2) # Y轴方向 self.y_dir_var = tk.IntVar(value=1) ttk.Checkbutton(ref_frame, text=反转Y轴方向, variable=self.y_dir_var).grid(row=2, column=0, columnspan=3, pady=5, sticky=w) # 操作按钮 btn_frame = ttk.Frame(control_frame) btn_frame.pack(fill=x, pady=10) #ttk.Button(btn_frame, text=转换坐标, style=Accent.TButton, command=self.transform_coords).pack(side=left, padx=2) ttk.Button(btn_frame, text=转换坐标, command=self.transform_coords).pack(side=left, padx=2) ttk.Button(btn_frame, text=复制结果, command=self.copy_results).pack(side=left, padx=2) ttk.Button(btn_frame, text=清空, command=self.clear_all).pack(side=right, padx=2) ttk.Button(btn_frame, text=示例数据, command=self.load_sample_data).pack(side=right, padx=2) # 结果显示 result_frame = ttk.LabelFrame(control_frame, text=转换结果, padding=10) result_frame.pack(fill=x, pady=5) self.result_text = tk.Text(result_frame, height=10, width=30, state=disabled, font=(Consolas, 9)) self.result_text.pack(fill=x) # 绑定事件 self.canvas.bind(Configure, self.draw_coordinates) def load_sample_data(self): 加载示例数据 sample_data = -3.079,-40.615 -14.124,-38.0110.771,-17.989-10.172,-16.0685.609,10.806-5.774,10.9199.346,34.571-1.755,36.34713.532,58.9042.343,61.267 self.coord_text.delete(1.0, tk.END) self.coord_text.insert(1.0, sample_data.strip()) self.y_dir_var.set(True) # 设置示例参考点坐标 self.a_x.delete(0, tk.END) self.a_x.insert(0, -3.079) self.a_y.delete(0, tk.END) self.a_y.insert(0, -40.615) self.b_x.delete(0, tk.END) self.b_x.insert(0, 0.771) self.b_y.delete(0, tk.END) self.b_y.insert(0, -17.989) def parse_input(self): 解析输入的坐标数据 self.points = [] text = self.coord_text.get(1.0, tk.END).strip() for line in text.split( ): if line.strip(): try: x, y = map(float, line.strip().split(,)) self.points.append([x, y]) except ValueError: continue return len(self.points) 0 def transform_coords(self): 执行坐标转换 if not self.parse_input(): messagebox.showerror(错误, 请输入有效的坐标数据) return try: a_x = float(self.a_x.get()) a_y = float(self.a_y.get()) b_x = float(self.b_x.get()) b_y = float(self.b_y.get()) self.y_direction = -1 if self.y_dir_var.get() else 1 except ValueError: messagebox.showerror(错误, 请设置有效的参考点坐标) return a = np.array([a_x, a_y]) b = np.array([b_x, b_y]) ab = b - a # 计算新坐标系基向量 e1 = ab / np.linalg.norm(ab) # X轴 e2 = np.array([-e1[1], e1[0]]) * (-1 if self.y_dir_var.get() else 1) # 保持功能但写法更清晰 # 构造变换矩阵 transform_matrix = np.array([e1, e2]).T # 转换所有点 self.transformed_points = [] for point in self.points: translated = np.array(point) - a new_coords = np.dot(transform_matrix.T, translated) self.transformed_points.append(new_coords.tolist()) # 显示结果 self.show_results() self.draw_coordinates() def show_results(self): 显示转换结果(保留8位小数) self.result_text.config(state=normal) self.result_text.delete(1.0, tk.END) for i, point in enumerate(self.transformed_points): self.result_text.insert(tk.END, fi:2d: point[0]:.8f, point[1]:.8f ) self.result_text.config(state=disabled) def copy_results(self): 复制结果到剪贴板(保留8位小数) if not self.transformed_points: return self.root.clipboard_clear() result = .join([fp[0]:.8f, p[1]:.8f for p in self.transformed_points]) self.root.clipboard_append(result) messagebox.showinfo(成功, 转换结果已复制到剪贴板) def clear_all(self): 清空所有数据 self.coord_text.delete(1.0, tk.END) self.result_text.config(state=normal) self.result_text.delete(1.0, tk.END) self.result_text.config(state=disabled) self.points = [] self.transformed_points = [] self.a_x.delete(0, tk.END) self.a_y.delete(0, tk.END) self.b_x.delete(0, tk.END) self.b_y.delete(0, tk.END) self.y_dir_var.set(1) self.canvas.delete(all) def draw_coordinates(self, event=None): 绘制坐标点 if not self.points: return self.canvas.delete(all) width = self.canvas.winfo_width() height = self.canvas.winfo_height() # 计算缩放和平移参数 all_points = self.points + ([p[:2] for p in self.transformed_points] if self.transformed_points else []) x_coords = [p[0] for p in all_points] y_coords = [p[1] for p in all_points] # 包含参考点 try: a_x = float(self.a_x.get()) a_y = float(self.a_y.get()) x_coords.append(a_x) y_coords.append(a_y) except ValueError: pass try: b_x = float(self.b_x.get()) b_y = float(self.b_y.get()) x_coords.append(b_x) y_coords.append(b_y) except ValueError: pass x_min, x_max = min(x_coords), max(x_coords) y_min, y_max = min(y_coords), max(y_coords) # 添加2%的边距 x_margin = (x_max - x_min) * 0.02 y_margin = (y_max - y_min) * 0.02 x_min -= x_margin if x_margin != 0 else 1 x_max += x_margin if x_margin != 0 else 1 y_min -= y_margin if y_margin != 0 else 1 y_max += y_margin if y_margin != 0 else 1 x_scale = width / (x_max - x_min) y_scale = height / (y_max - y_min) scale = min(x_scale, y_scale) * 0.98 # 保持纵横比 # 转换函数 def transform_point(x, y): canvas_x = (x - x_min) * scale + (width - (x_max - x_min) * scale) / 2 canvas_y = height - ((y - y_min) * scale + (height - (y_max - y_min) * scale) / 2) return canvas_x, canvas_y # 绘制坐标轴 ox, oy = transform_point(0, 0) # 原点坐标 self.canvas.create_line(0, oy, width, oy, fill=#999999, dash=(2,2), arrow=tk.LAST) # X轴 self.canvas.create_line(ox, height, ox, 0, fill=#999999, dash=(2,2), arrow=tk.LAST) # Y轴 # 绘制原始坐标点（红色） for i, point in enumerate(self.points): x, y = transform_point(point[0], point[1]) color = #FF4444 # 红色 self.canvas.create_oval(x-5, y-5, x+5, y+5, fill=color, outline=black, width=1) self.canvas.create_text(x, y+15, text=str(i), font=(Arial, 8)) # 绘制转换后坐标点（绿色） if self.transformed_points: for i, point in enumerate(self.transformed_points): x, y = transform_point(point[0], point[1]) color = #44CC44 # 绿色 self.canvas.create_oval(x-5, y-5, x+5, y+5, fill=color, outline=black, width=1) self.canvas.create_text(x, y-15, text=str(i), font=(Arial, 8))if __name__ == __main__:\troot = tk.Tk()\tapp = CoordinateTransformer(root)\troot.mainloop()# pyinstaller -F -w -i my.ico --hidden-import numpy name.py","tags":["python"],"categories":["工具使用"]},{"title":"VIM使用教程","path":"/工具使用/VIM使用/","content":"VIM使用一、移动1.1单个字符移动 按键 功能 h 左移 j 下移 k 上移 l 右移 1.2 行首尾移动 按键 功能 0g0 移动到本行开头 ^g^ 移动到本行第一个字符 $g$ 移动到结尾 1.3 单词之间移动 按键 功能 be 单词开头单词结尾 f+char 跳转到char位置处 1.4 整文移动 按键 功能 gg 移动到第一行 G 移动到最后一行 o 在下一行插入 iI 在光标前后插入 ngg 跳转到第n行 二、剪切删除粘贴 按键 功能 dnd 剪切光标所在行及下面n行 dd 剪切当前行 diw 剪切当前单词 dngg 剪切本行到第n行 di( 删除（）中的内容 da（ 删除包括（）及内的内容 c 删除 y 复制 p 粘贴 三、跳转 按键 功能 % 移动到对应括号的另一对 ctrl+o 回到跳转之前 ctrl+i 回到跳转之后 gh 悬浮查看文档、签名 gd 跳转到定义声明处 ctrl+f 向上滚动整个屏幕 ctrl+b 向下滚动整个屏幕 ctrl+u 向上滚动半屏 ctrl+d 向下滚动半屏 四、其他 按键 功能 zz 使当前行成为屏幕中间一行 格式化代码 ggG 格式化整个文件 n 格式化下面n行 gcc 注释本行代码 gcnj 注释本行及下方n行的代码 ctrl+0 跳转到侧 l 回到代码区 ：q！ 退出当前标签 gt 跳转到下一个标签页 ngt 跳转到第n个标签页 v 进入可视化模式 ctrl+v 可选择列 V 可选择行 string 查找，nN翻找 %s目标操作gc 替换字符串，并确认 2,11smng 2-11行替换","tags":["Linux"],"categories":["工具使用"]},{"title":"使用Git管理keil工程","path":"/工具使用/使用Git管理keil工程/","content":"在软件开发领域，版本控制是非常重要的一环。它能够让我们追踪代码的变化、合作开发、管理不同的版本以及回滚到之前的状态。Git 是一个流行的分布式版本控制系统，本文将向你介绍如何使用 Git 来管理你的代码（以keil工程为例）。 一、Git Bush的配置在使用git之前，我们需要对用户名，邮箱等信息进行配置，作为用户标识，方便对工程的使用、管理。 界面美化 一个好看的界面是必要的，我们可以通过打开Git Bush后，点击上方的边框,选择Options来进配置。 1，修改中文 Options → Window → UI language，选择zh_CN。 2，界面配置 我使用的配置如下: 3，效果 个人信息配置 打开Git Bush依次输入以下命令 git config --global user.name 名称git config --global user.email 邮箱地址git config --global user.password 密码 当然，你可以输入以下命令查询个人配置信息 git config --global --list 配置SSH密钥 如果我们要将代码上传到远程仓库（这里以gitee举例），每次上传文件时都需要输入gitee的用户名和账号，十分麻烦。我们可以本地生成SSH公钥与远程仓库绑定，实现免密登录。 找到.ssh文件：C盘 → 用户 → .ssh 在.ssh文件中，右键点击Git Bush Here，打开Git Bush。并输入以下命令后连续点击回车键，直到出现以下情况，同时.ssh文件中生成id_rsa和id_rsa.pub两个文件。 ssh-keygen -t rsa 复制id_rsa.pub中的内容到gitee → 账号设置 → 安全管理 → SSH公钥中，点击确定。 二、配置.gitignore文件在对工程操作之前，我们还需要对工程进行一项配置，创建.gitignore文件，在里面添加不需要追踪的文件，它们将不会被 Git 跟踪和提交，忽略他们，可以节省上传速度和空间。 这是我的keil工程配置的忽略文件，Library*是我保存STM32标准库的文件夹，其他都是文件代码编译过程中生成文件。 *.bak*.ddk*.edk*.lst*.lnp*.mpf*.mpj*.obj*.omf*.plg*.rpt*.tmp*.__i*.crf*.o*.d*.axf*.tra*.dep JLinkLog.txt*.iex*.htm*.sct*.map*.Administrator*.uvoptLibrary/* 当然，你可以自行按以下语法手动添加文件。 文件名.gitignore忽略所有的 .log 文件*.log忽略 build 文件夹和里面所有的内容build/忽略所有的 .txt 文件，但保留 example.txt*.txt!example.txt 将配置好的.gitignore放在工程中即可。 三、正式操作 在工程中打开Git Bush 创建仓库 git init 将文件添加到暂存区 git add . 提交到本地 git commit -m 提交描述 连接远程 git remote add origin xxxxxx为远程仓库地址，你可自行在gitee上创建仓库 提交到远程仓库 git push -u origin master 在以后的操作中，你只需要不断重复进行三个命令即可： 1.加入追踪git add . 2.提交git commit -m 提交描述 3.提交到远程（也可不进行）git push -u origin master 还有几个命令我们也经常会用到： 查看当前文件状态，判断文件是否被追踪（红色表示未追踪） git status 查看提交日志（可以查看已保存版本的版本号，提交者，日期，提交信息） git log 返回以前版本 你可以返回到之前版本的工程。 git reset --hard 版本号 其版本号可通过查看提交日志获取。 以上就是全部内容了，希望对各位有所帮助，同时期待你的指正!","tags":["Git"],"categories":["工具使用"]}]